using System;
using System.Collections.Generic;
using System.CommandLine;
using System.CommandLine.Parsing;
using System.Linq;
using System.Reflection;
using DotMake.CommandLine.Binding;

namespace DotMake.CommandLine
{
    /// <summary>
    /// Represents a command builder generated by the source generator.
    /// </summary>
    public abstract class CliCommandBuilder
    {
        /// <summary>
        /// A delegate which is set by the source generator to be called from <see cref="Bind"/> method.
        /// </summary>
        protected Func<ParseResult, object> BindFunc;

        /// <summary>
        /// Initializes a new instance of the <see cref="CliCommandBuilder" /> class.
        /// </summary>
        protected CliCommandBuilder()
        {
            var defaults = CliCommandAttribute.Default;
            NameCasingConvention = defaults.NameCasingConvention;
            NamePrefixConvention = defaults.NamePrefixConvention;
            ShortFormPrefixConvention = defaults.ShortFormPrefixConvention;
            ShortFormAutoGenerate = defaults.ShortFormAutoGenerate;
        }

        /// <summary>
        /// The definition class that this command builder is generated for.
        /// </summary>
        public Type DefinitionType { get; protected set; }

        /// <summary>
        /// The parent definition class if this command builder is generated for a nested/external child.
        /// </summary>
        public Type ParentDefinitionType { get; protected set; }

        /// <summary>
        /// Gets the character casing convention used for automatically generated command, option and argument names.
        /// </summary>
        public CliNameCasingConvention NameCasingConvention { get; protected set; }

        /// <summary>
        /// Gets the prefix convention used for automatically generated option names.
        /// </summary>
        public CliNamePrefixConvention NamePrefixConvention { get; protected set; }

        /// <summary>
        /// Gets the prefix convention used for automatically generated short form option aliases.
        /// </summary>
        public CliNamePrefixConvention ShortFormPrefixConvention { get; protected set; }

        /// <summary>
        /// Gets a value which indicates whether short form aliases were automatically generated for options.
        /// </summary>
        public bool ShortFormAutoGenerate { get; protected set; }

        /// <summary>
        /// Builds a <see cref="CliCommand"/> instance, populated with sub-commands, options, arguments and settings.
        /// </summary>
        /// <returns>A populated <see cref="CliCommand"/> instance.</returns>
        public abstract CliCommand Build();

        /// <summary>
        /// Creates a new instance of the definition class and binds/populates the properties from the parse result.
        /// </summary>
        /// <param name="parseResult">A parse result describing the outcome of the parse operation.</param>
        /// <returns>An instance of the definition class whose properties were bound/populated from the parse result.</returns>
        public object Bind(ParseResult parseResult)
        {
            if (BindFunc == null)
                throw new Exception("Ensure Build method is called first.");

            return BindFunc(parseResult);
        }

        /// <summary>
        /// Gets the command builders that are nested/external children of this command builder.
        /// </summary>
        public IEnumerable<CliCommandBuilder> Children => GetChildren(DefinitionType);

        /// <summary>
        /// Registers this command builder so that it can be found by the definition class,
        /// and it can be found by the parent definition class if it's a nested/external child.
        /// </summary>
        public void Register()
        {
            if (DefinitionType != null)
                Register(DefinitionType, this);

            if (ParentDefinitionType != null)
                RegisterAsChild(ParentDefinitionType, this);
        }

        #region Static

        private static readonly Dictionary<Type, CliCommandBuilder> RegisteredDefinitionTypes =
            new Dictionary<Type, CliCommandBuilder>();

        private static readonly Dictionary<Type, HashSet<CliCommandBuilder>> RegisteredParentDefinitionTypes =
            new Dictionary<Type, HashSet<CliCommandBuilder>>();

        /// <summary>
        /// Registers a command builder so that it can be found by the definition class.
        /// </summary>
        /// <param name="commandBuilder">A command builder which builds a <see cref="CliCommand"/>.</param>
        /// <typeparam name="TDefinition">The definition class.</typeparam>
        public static void Register<TDefinition>(CliCommandBuilder commandBuilder)
        {
            var definitionType = typeof(TDefinition);

            Register(definitionType, commandBuilder);
        }

        /// <summary>
        /// Registers a command builder so that it can be found by the definition class.
        /// </summary>
        /// <param name="definitionType">The type of the definition class.</param>
        /// <param name="commandBuilder">A command builder which builds a <see cref="CliCommand"/>.</param>
        public static void Register(Type definitionType, CliCommandBuilder commandBuilder)
        {
            RegisteredDefinitionTypes[definitionType] = commandBuilder;
        }

        /// <summary>
        /// Gets the command builder registered for the definition class.
        /// </summary>
        /// <typeparam name="TDefinition">The definition class.</typeparam>
        /// <returns>The registered <see cref="CliCommandBuilder" /> instance.</returns>
        public static CliCommandBuilder Get<TDefinition>()
        {
            var definitionType = typeof(TDefinition);

            return Get(definitionType);
        }

        /// <summary>
        /// Gets the command builder registered for the definition class.
        /// </summary>
        /// <param name="definitionType">The type of the definition class.</param>
        /// <returns>The registered <see cref="CliCommandBuilder" /> instance.</returns>
        public static CliCommandBuilder Get(Type definitionType)
        {
            if (!RegisteredDefinitionTypes.TryGetValue(definitionType, out var commandBuilder))
            {
                if (definitionType.GetCustomAttribute<CliCommandAttribute>() == null)
                    throw new Exception($"The class '{definitionType.Name}' should have [CliCommand] attribute.");

                var parentWithoutAttribute = definitionType.RecurseWhileNotNull(t => t.DeclaringType)
                    .FirstOrDefault(t => t.GetCustomAttribute<CliCommandAttribute>() == null);
                if (parentWithoutAttribute != null) //nested
                    throw new Exception($"The parent class '{parentWithoutAttribute.Name}' of nested class '{definitionType.Name}' should have [CliCommand] attribute.");


                throw new Exception($"A registered command builder is not found for '{definitionType.Name}'. " +
                                    $"Please ensure the source generator is running and generating a command builder for your definition class.");
            }

            return commandBuilder;
        }

        /// <summary>
        /// Registers a command builder as a nested/external child so that it can be found by the parent definition class.
        /// </summary>
        /// <param name="childCommandBuilder">The nested/external child command builder.</param>
        /// <typeparam name="TParentDefinition">The parent definition class.</typeparam>
        public static void RegisterAsChild<TParentDefinition>(CliCommandBuilder childCommandBuilder)
        {
            var parentDefinitionType = typeof(TParentDefinition);

            RegisterAsChild(parentDefinitionType, childCommandBuilder);
        }

        /// <summary>
        /// Registers a command builder as a nested/external child so that it can be found by the parent definition class.
        /// </summary>
        /// <param name="parentDefinitionType">The type of the parent definition class.</param>
        /// <param name="childCommandBuilder">The nested/external child command builder.</param>
        public static void RegisterAsChild(Type parentDefinitionType, CliCommandBuilder childCommandBuilder)
        {
            if (!RegisteredParentDefinitionTypes.TryGetValue(parentDefinitionType, out var children))
                RegisteredParentDefinitionTypes[parentDefinitionType] = children = new HashSet<CliCommandBuilder>();

            children.Add(childCommandBuilder);
        }

        /// <summary>
        /// Gets the command builders that are registered as nested/external children of a parent definition.
        /// </summary>
        /// <typeparam name="TParentDefinition">The parent definition class.</typeparam>
        /// <returns>An enumerable whose elements are the <see cref="CliCommandBuilder" /> instances registered as nested/external children.</returns>
        public static IEnumerable<CliCommandBuilder> GetChildren<TParentDefinition>()
        {
            var parentDefinitionType = typeof(TParentDefinition);

            return GetChildren(parentDefinitionType);
        }

        /// <summary>
        /// Gets the command builders that are registered as nested/external children of a parent definition.
        /// </summary>
        /// <param name="parentDefinitionType">The type of the parent definition class.</param>
        /// <returns>An enumerable whose elements are the <see cref="CliCommandBuilder" /> instances registered as nested/external children.</returns>
        public static IEnumerable<CliCommandBuilder> GetChildren(Type parentDefinitionType)
        {
            if (parentDefinitionType == null
                || !RegisteredParentDefinitionTypes.TryGetValue(parentDefinitionType, out var children))
                return Enumerable.Empty<CliCommandBuilder>();

            return children;
        }

        /// <summary>
        /// Gets an argument parser method for an argument type, if it's a collection type.
        /// <para>
        /// This is mainly used for adding support for all <see cref="IEnumerable{T}"/> compatible types which have
        /// a public constructor with a <see cref="IEnumerable{T}"/> or <see cref="IList{T}"/> parameter (other parameters, if any, should be optional).
        /// </para>
        /// </summary>
        /// <param name="convertFromArray">A delegate which creates an instance of collection type from an array.</param>
        /// <param name="convertFromString">A delegate which creates an instance of item type from a string.</param>
        /// <typeparam name="TCollection">The collection type, the argument type itself.</typeparam>
        /// <typeparam name="TItem">The item type, e.g. if argument type is IEnumerable&lt;T&gt;, item type will be T.</typeparam>
        /// <returns>A delegate which can be passed to an option or argument.</returns>
        public static Func<ArgumentResult, TCollection> GetArgumentParser<TCollection, TItem>(Func<Array, TCollection> convertFromArray, Func<string, TItem> convertFromString = null)
        {
            ArgumentConverter.RegisterCollectionConverter(convertFromArray);
            ArgumentConverter.RegisterStringConverter(convertFromString);

            return GetArgumentParser<TCollection>();
        }


        /// <summary>
        /// Gets an argument parser method for an argument type.
        /// <para>
        /// This is mainly used for adding support for binding custom types which have a public constructor
        /// or a static <c>Parse</c> method with a string parameter (other parameters, if any, should be optional).
        /// </para>
        /// </summary>
        /// <param name="convertFromString">A delegate which creates an instance of custom type from a string.</param>
        /// <typeparam name="TArgument">The argument type.</typeparam>
        /// <returns>A delegate which can be passed to an option or argument.</returns>
        public static Func<ArgumentResult, TArgument> GetArgumentParser<TArgument>(Func<string, TArgument> convertFromString = null)
        {
            ArgumentConverter.RegisterStringConverter(convertFromString);

            return (result) =>
            {
                var tryConvertArgument = ArgumentConverter.GetConverter(result.Argument);

                if (tryConvertArgument == null)
                {
                    result.AddError($"No argument converter found for type '{result.Argument.ValueType}'");
                    return default; // Ignored.
                }

                tryConvertArgument(result, out var value);

                return value != null
                    ? (TArgument)value
                    : default;
            };
        }

        /// <summary>
        /// Gets the parsed or default value for the specified option.
        /// <para>
        /// Extended version for DotMake CLI which can bind custom classes,
        /// does not fall back to internal ArgumentConverter.GetDefaultValue which does not support all IList compatible types.
        /// </para>
        /// </summary>
        /// <param name="parseResult">The parse result.</param>
        /// <param name="option">The option for which to get a value.</param>
        /// <typeparam name="T">The option type.</typeparam>
        /// <returns>The parsed value or a configured default.</returns>
        public static T GetValueForOption<T>(ParseResult parseResult, CliOption<T> option)
        {
            var result = parseResult.GetResult(option);
            if (result != null)
            {
                var value = result.GetValueOrDefault<T>();
                if (value != null)
                    return value;
            }

            return (T)ArgumentConverter.GetDefaultValue(typeof(T));
        }

        /// <inheritdoc cref="GetValueForOption{T}"/>
        public static object GetValueForOption(ParseResult parseResult, CliOption option)
        {
            var result = parseResult.GetResult(option);
            if (result != null)
            {
                var value = result.GetValueOrDefault<object>();
                if (value != null)
                    return value;
            }

            return ArgumentConverter.GetDefaultValue(option.GetArgument().ValueType);
        }

        /// <summary>
        /// Gets the parsed or default value for the specified argument.
        /// <para>
        /// Extended version for DotMake CLI which can bind custom classes,
        /// does not fall back to internal ArgumentConverter.GetDefaultValue which does not support all IList compatible types.
        /// </para>
        /// </summary>
        /// <param name="parseResult">The parse result.</param>
        /// <param name="argument">The argument for which to get a value.</param>
        /// <typeparam name="T">The argument type.</typeparam>
        /// <returns>The parsed value or a configured default.</returns>
        public static T GetValueForArgument<T>(ParseResult parseResult, CliArgument<T> argument)
        {
            var result = parseResult.GetResult(argument);
            if (result != null)
            {
                var value = result.GetValueOrDefault<T>();
                if (value != null)
                    return value;
            }

            return (T)ArgumentConverter.GetDefaultValue(typeof(T));
        }

        /// <inheritdoc cref="GetValueForArgument{T}"/>
        public static object GetValueForArgument(ParseResult parseResult, CliArgument argument)
        {
            var result = parseResult.GetResult(argument);
            if (result != null)
            {
                var value = result.GetValueOrDefault<object>();
                if (value != null)
                    return value;
            }

            return ArgumentConverter.GetDefaultValue(argument.ValueType);
        }

        #endregion
    }
}
