using System;
using System.Collections.Generic;
using System.CommandLine;
using System.Linq;
using System.Reflection;
using DotMake.CommandLine.Util;

namespace DotMake.CommandLine
{
    /// <summary>
    /// Represents a command builder generated by the source generator.
    /// </summary>
    public abstract class CliCommandBuilder
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CliCommandBuilder" /> class.
        /// </summary>
        protected CliCommandBuilder()
        {
        }

        /// <summary>
        /// The definition class that this command builder is generated for.
        /// </summary>
        public Type DefinitionType { get; protected set; }

        /// <summary>
        /// The parent definition class if this command builder is generated for a nested/external child.
        /// </summary>
        public Type ParentDefinitionType { get; protected set; }

        /// <summary>
        /// The child definition classes if this command builder is generated for an external parent.
        /// </summary>
        public Type[] ChildDefinitionTypes { get; protected set; }


        /// <summary>
        /// Gets a value which indicates whether names are automatically generated for commands, directives, options and arguments.
        /// </summary>
        public CliNameAutoGenerate? NameAutoGenerate { get; protected set; }

        /// <summary>
        /// Gets the character casing convention to use for automatically generated names of commands, directives, options and arguments.
        /// </summary>
        public CliNameCasingConvention? NameCasingConvention { get; protected set; }

        /// <summary>
        /// Gets the prefix convention to use for automatically generated names of options.
        /// </summary>
        public CliNamePrefixConvention? NamePrefixConvention { get; protected set; }

        /// <summary>
        /// Gets a value which indicates whether short form aliases are automatically generated names of commands and options.
        /// </summary>
        public CliNameAutoGenerate? ShortFormAutoGenerate { get; protected set; }

        /// <summary>
        /// Gets the prefix convention to use for automatically generated short form aliases of options.
        /// </summary>
        public CliNamePrefixConvention? ShortFormPrefixConvention { get; protected set; }

        /// <summary>
        /// Gets the namer for generating CLI names and aliases while tracking already used ones.
        /// This will be available after <see cref="Build"/> call.
        /// </summary>
        public CliNamer Namer { get; protected set; }


        /// <summary>
        /// Gets the command builders that are nested/external children of this command builder.
        /// </summary>
        public IEnumerable<CliCommandBuilder> Children => GetChildren(DefinitionType);

        /// <summary>
        /// Gets the command builders that are nested/external parents of this command builder.
        /// </summary>
        public IEnumerable<CliCommandBuilder> Parents => GetParents(DefinitionType);

        /// <summary>
        /// Gets a value which indicates whether this command builder is for a root command.
        /// </summary>
        public bool IsRoot => !RegisteredChildMap.ContainsKey(DefinitionType);


        /// <summary>
        /// Builds a <see cref="Command"/> instance with full hierarchy, populated with parent-commands, sub-commands, directives, options, arguments and settings.
        /// </summary>
        /// <returns>A populated <see cref="Command"/> instance.</returns>
        public Command BuildWithHierarchy(CliBindingContext bindingContext, out RootCommand rootCommand)
        {
            var commandBuilder = this;

            rootCommand = null;
            CliCommandBuilder parent = null;
            Command parentCommand = null;
            Command currentCommand = null;

            // Add nested or external registered parent commands
            foreach (var current in commandBuilder.Parents.Reverse().Append(commandBuilder))
            {
                currentCommand = current.BuildWithParent(bindingContext, parent);
                parentCommand?.Add(currentCommand);

                if (parent == null)
                    rootCommand = currentCommand as RootCommand;

                parent = current;
                parentCommand = currentCommand;
            }
            var command = currentCommand!; //always non-null

            // Add nested or external registered children commands
            // Use Queue (breadth-first) for correct order here
            var queue = new Queue<Tuple<CliCommandBuilder, Command>>();
            queue.Enqueue(Tuple.Create(commandBuilder, command));
            while (queue.Count > 0)
            {
                var parentTuple = queue.Dequeue();
                parent = parentTuple.Item1;
                parentCommand = parentTuple.Item2;

                foreach (var current in parent.Children)
                {
                    currentCommand = current.BuildWithParent(bindingContext, parent);
                    parentCommand?.Add(currentCommand);

                    queue.Enqueue(Tuple.Create(current, currentCommand));
                }
            }


            /*
            //Testing command hierarchy
            var topCommandBuilder = commandBuilder.Parents.LastOrDefault() ?? commandBuilder;
            var queue2 = new Queue<CliCommandBuilder>();
            queue2.Enqueue(topCommandBuilder);
            while (queue2.Count > 0)
            {
                var current = queue2.Dequeue();

                var depth = current.Parents.Count();
                Console.Write(new string(' ', 2 * depth));
                Console.WriteLine($@"{current.DefinitionType.Name} (depth: {depth})");

                foreach (var child in current.Children)
                {
                    queue2.Enqueue(child);
                }
            }
            */

            return command;
        }

        /// <summary>
        /// Builds a <see cref="Command"/> instance by inheriting parent settings, populated with directives, options, arguments and settings.
        /// </summary>
        /// <returns>A populated <see cref="Command"/> instance.</returns>
        public Command BuildWithParent(CliBindingContext bindingContext, CliCommandBuilder parent)
        {
            if (parent == null) //if no parent, treat as single command build
                return Build(bindingContext); 

            //Should be before Build
            //Inherit settings from a parent command builder.
            //If a setting is not null in this command builder, then that will be used instead.
            Namer = new CliNamer
            (
                NameAutoGenerate,
                NameCasingConvention,
                NamePrefixConvention,
                ShortFormAutoGenerate,
                ShortFormPrefixConvention,
                parent.Namer //Use the parent namer to check names and aliases of sub-commands and cascade settings inheritance.
            );

            return DoBuild(bindingContext);
        }

        /// <summary>
        /// Builds a <see cref="Command"/> instance, populated with directives, options, arguments and settings.
        /// </summary>
        /// <returns>A populated <see cref="Command"/> instance.</returns>
        public Command Build(CliBindingContext bindingContext)
        {
            Namer = new CliNamer
            (
                NameAutoGenerate,
                NameCasingConvention,
                NamePrefixConvention,
                ShortFormAutoGenerate,
                ShortFormPrefixConvention
            );

            return DoBuild(bindingContext);
        }

        /// <summary>
        /// Builds a <see cref="Command"/> instance, populated with directives, options, arguments and settings.
        /// </summary>
        /// <returns>A populated <see cref="Command"/> instance.</returns>
        protected abstract Command DoBuild(CliBindingContext bindingContext);


        /// <summary>
        /// Registers this command builder so that it can be found by the definition class,
        /// and it can be found by the parent definition class if it's a nested/external child.
        /// </summary>
        public void Register()
        {
            if (DefinitionType != null)
                Register(DefinitionType, this);

            if (ParentDefinitionType != null)
                RegisterAsChild(ParentDefinitionType, DefinitionType);

            if (ChildDefinitionTypes != null)
                foreach (var childDefinitionType in ChildDefinitionTypes)
                {
                    if (childDefinitionType != null)
                        RegisterAsChild(DefinitionType, childDefinitionType);
                }
        }


        #region Static

        private static readonly Dictionary<Type, CliCommandBuilder> RegisteredCommandBuilders = new();

        private static readonly Dictionary<Type, HashSet<Type>> RegisteredParentMap = new();

        private static readonly Dictionary<Type, Type> RegisteredChildMap = new();

        /// <summary>
        /// Registers a command builder so that it can be found by the definition class.
        /// </summary>
        /// <param name="commandBuilder">A command builder which builds a <see cref="Command"/>.</param>
        /// <typeparam name="TDefinition">The definition class.</typeparam>
        public static void Register<TDefinition>(CliCommandBuilder commandBuilder)
        {
            var definitionType = typeof(TDefinition);

            Register(definitionType, commandBuilder);
        }

        /// <summary>
        /// Registers a command builder so that it can be found by the definition class.
        /// </summary>
        /// <param name="definitionType">The type of the definition class.</param>
        /// <param name="commandBuilder">A command builder which builds a <see cref="Command"/>.</param>
        public static void Register(Type definitionType, CliCommandBuilder commandBuilder)
        {
            RegisteredCommandBuilders[definitionType] = commandBuilder;
        }

        /// <summary>
        /// Gets the command builder registered for the definition class.
        /// </summary>
        /// <typeparam name="TDefinition">The definition class.</typeparam>
        /// <returns>The registered <see cref="CliCommandBuilder" /> instance.</returns>
        public static CliCommandBuilder Get<TDefinition>()
        {
            var definitionType = typeof(TDefinition);

            return Get(definitionType);
        }

        /// <summary>
        /// Gets the command builder registered for the definition class.
        /// </summary>
        /// <param name="definitionType">The type of the definition class.</param>
        /// <returns>The registered <see cref="CliCommandBuilder" /> instance.</returns>
        public static CliCommandBuilder Get(Type definitionType)
        {
            if (!RegisteredCommandBuilders.TryGetValue(definitionType, out var commandBuilder))
            {
                if (definitionType.GetCustomAttribute<CliCommandAttribute>() == null)
                    throw new Exception($"The class '{definitionType.Name}' should have [CliCommand] attribute.");

                var parentWithoutAttribute = definitionType.WhileNotNull(t => t.DeclaringType)
                    .FirstOrDefault(t => t.GetCustomAttribute<CliCommandAttribute>() == null);
                if (parentWithoutAttribute != null) //nested
                    throw new Exception($"The parent class '{parentWithoutAttribute.Name}' of nested class '{definitionType.Name}' should have [CliCommand] attribute.");


                throw new Exception($"A registered command builder is not found for '{definitionType.Name}'. " +
                                    $"Please ensure the source generator is running and generating a command builder for your definition class.");
            }

            return commandBuilder;
        }

        /// <summary>
        /// Registers a command builder as a nested/external child so that it can be found by the parent definition class.
        /// </summary>
        /// <typeparam name="TParentDefinition">The parent definition class.</typeparam>
        /// <typeparam name="TChildDefinition">The child definition class.</typeparam>
        public static void RegisterAsChild<TParentDefinition, TChildDefinition>()
        {
            var parentDefinitionType = typeof(TParentDefinition);
            var childDefinitionType = typeof(TChildDefinition);

            RegisterAsChild(parentDefinitionType, childDefinitionType);
        }

        /// <summary>
        /// Registers a command builder as a nested/external child so that it can be found by the parent definition class.
        /// </summary>
        /// <param name="parentDefinitionType">The type of the parent definition class.</param>
        /// <param name="childDefinitionType">The type of the child definition class.</param>
        public static void RegisterAsChild(Type parentDefinitionType, Type childDefinitionType)
        {
            if (!RegisteredParentMap.TryGetValue(parentDefinitionType, out var children))
                RegisteredParentMap[parentDefinitionType] = children = new HashSet<Type>();

            children.Add(childDefinitionType);

            if (!RegisteredChildMap.ContainsKey(childDefinitionType))
                RegisteredChildMap.Add(childDefinitionType, parentDefinitionType);

            /*
            if (childCommandBuilder.ParentDefinitionType != null)
            {
                if (RegisteredDefinitionTypes.TryGetValue(childCommandBuilder.ParentDefinitionType, out var parent))
                    RegisteredParentDefinitionTypes[childCommandBuilder.DefinitionType] = parent;
            }
            */
        }

        /// <summary>
        /// Gets the command builders that are registered as nested/external children of a parent definition.
        /// </summary>
        /// <typeparam name="TParentDefinition">The parent definition class.</typeparam>
        /// <returns>An enumerable whose elements are the <see cref="CliCommandBuilder" /> instances registered as nested/external children.</returns>
        public static IEnumerable<CliCommandBuilder> GetChildren<TParentDefinition>()
        {
            var parentDefinitionType = typeof(TParentDefinition);

            return GetChildren(parentDefinitionType);
        }

        /// <summary>
        /// Gets the command builders that are registered as nested/external children of a parent definition.
        /// </summary>
        /// <param name="parentDefinitionType">The type of the parent definition class.</param>
        /// <returns>An enumerable whose elements are the <see cref="CliCommandBuilder" /> instances registered as nested/external children.</returns>
        public static IEnumerable<CliCommandBuilder> GetChildren(Type parentDefinitionType)
        {
            if (parentDefinitionType != null
                && RegisteredParentMap.TryGetValue(parentDefinitionType, out var children))
            {
                foreach (var child in children)
                {
                    if (RegisteredCommandBuilders.TryGetValue(child, out var childCommandBuilder))
                        yield return childCommandBuilder;
                }
            }
        }

        /// <summary>
        /// Gets the command builders that are registered as nested/external parents of a child definition.
        /// </summary>
        /// <typeparam name="TDefinition">The child definition class.</typeparam>
        /// <returns>An enumerable whose elements are the <see cref="CliCommandBuilder" /> instances registered as nested/external parents.</returns>
        public static IEnumerable<CliCommandBuilder> GetParents<TDefinition>()
        {
            var definitionType = typeof(TDefinition);

            return GetParents(definitionType);
        }
        
        /// <summary>
        /// Gets the command builders that are registered as nested/external parents of a child definition.
        /// </summary>
        /// <param name="definitionType">The type of the child definition class.</param>
        /// <returns>An enumerable whose elements are the <see cref="CliCommandBuilder" /> instances registered as nested/external parents.</returns>
        public static IEnumerable<CliCommandBuilder> GetParents(Type definitionType)
        {
            while (definitionType != null)
            {
                if (RegisteredCommandBuilders.TryGetValue(definitionType, out var commandBuilder)
                    && commandBuilder.ParentDefinitionType != null
                    && RegisteredParentMap.TryGetValue(commandBuilder.ParentDefinitionType, out var children)
                    && children.Contains(commandBuilder.DefinitionType)
                    && RegisteredCommandBuilders.TryGetValue(commandBuilder.ParentDefinitionType, out var parentCommandBuilder))
                {
                    yield return parentCommandBuilder;

                    definitionType = parentCommandBuilder.DefinitionType;
                }
                else
                    yield break;
            }
        }

        #endregion
    }
}
