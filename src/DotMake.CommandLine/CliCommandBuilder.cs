using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.CommandLine;
using System.CommandLine.Parsing;
using System.Linq;
using System.Reflection;
using DotMake.CommandLine.Binding;
using DotMake.CommandLine.Util;

namespace DotMake.CommandLine
{
    /// <summary>
    /// Represents a command builder generated by the source generator.
    /// </summary>
    public abstract class CliCommandBuilder
    {
        private readonly ConcurrentDictionary<ParseResult, object> bindResults = new();

        /// <summary>
        /// A delegate which is set by the source generator to be called from <see cref="Bind(ParseResult)"/> method.
        /// </summary>
        protected Func<ParseResult, object> Binder;

        /// <summary>
        /// The service provider if it is used. This will be disposed at the end of the execution.
        /// </summary>
        protected IServiceProvider ServiceProvider;


        /// <summary>
        /// Initializes a new instance of the <see cref="CliCommandBuilder" /> class.
        /// </summary>
        protected CliCommandBuilder()
        {
        }

        /// <summary>
        /// The definition class that this command builder is generated for.
        /// </summary>
        public Type DefinitionType { get; protected set; }

        /// <summary>
        /// The parent definition class if this command builder is generated for a nested/external child.
        /// </summary>
        public Type ParentDefinitionType { get; protected set; }

        /// <summary>
        /// The child definition classes if this command builder is generated for an external parent.
        /// </summary>
        public Type[] ChildDefinitionTypes { get; protected set; }


        /// <summary>
        /// Gets a value which indicates whether names are automatically generated for commands, directives, options and arguments.
        /// </summary>
        public CliNameAutoGenerate? NameAutoGenerate { get; protected set; }

        /// <summary>
        /// Gets the character casing convention to use for automatically generated names of commands, directives, options and arguments.
        /// </summary>
        public CliNameCasingConvention? NameCasingConvention { get; protected set; }

        /// <summary>
        /// Gets the prefix convention to use for automatically generated names of options.
        /// </summary>
        public CliNamePrefixConvention? NamePrefixConvention { get; protected set; }

        /// <summary>
        /// Gets a value which indicates whether short form aliases are automatically generated names of commands and options.
        /// </summary>
        public CliNameAutoGenerate? ShortFormAutoGenerate { get; protected set; }

        /// <summary>
        /// Gets the prefix convention to use for automatically generated short form aliases of options.
        /// </summary>
        public CliNamePrefixConvention? ShortFormPrefixConvention { get; protected set; }

        /// <summary>
        /// Gets the namer for generating CLI names and aliases while tracking already used ones.
        /// This will be available after <see cref="Build"/> call.
        /// </summary>
        public CliNamer Namer { get; protected set; }


        /// <summary>
        /// Gets the command builders that are nested/external children of this command builder.
        /// </summary>
        public IEnumerable<CliCommandBuilder> Children => GetChildren(DefinitionType);

        /// <summary>
        /// Gets the command builders that are nested/external parents of this command builder.
        /// </summary>
        public IEnumerable<CliCommandBuilder> Parents => GetParents(DefinitionType);

        /// <summary>
        /// Gets a value which indicates whether this command builder is for a root command.
        /// </summary>
        public bool IsRoot => !RegisteredChildMap.ContainsKey(DefinitionType);


        /// <summary>
        /// Builds a <see cref="Command"/> instance with full hierarchy, populated with parent-commands, sub-commands, directives, options, arguments and settings.
        /// </summary>
        /// <returns>A populated <see cref="Command"/> instance.</returns>
        public Command BuildWithHierarchy(out RootCommand rootCommand)
        {
            var commandBuilder = this;

            rootCommand = null;
            CliCommandBuilder parent = null;
            Command parentCommand = null;
            Command currentCommand = null;

            // Add nested or external registered parent commands
            foreach (var current in commandBuilder.Parents.Reverse().Append(commandBuilder))
            {
                currentCommand = current.BuildWithParent(parent);
                parentCommand?.Add(currentCommand);

                if (parent == null)
                    rootCommand = currentCommand as RootCommand;

                parent = current;
                parentCommand = currentCommand;
            }
            var command = currentCommand!; //always non-null

            // Add nested or external registered children commands
            // Use Queue (breadth-first) for correct order here
            var queue = new Queue<Tuple<CliCommandBuilder, Command>>();
            queue.Enqueue(Tuple.Create(commandBuilder, command));
            while (queue.Count > 0)
            {
                var parentTuple = queue.Dequeue();
                parent = parentTuple.Item1;
                parentCommand = parentTuple.Item2;

                foreach (var current in parent.Children)
                {
                    currentCommand = current.BuildWithParent(parent);
                    parentCommand?.Add(currentCommand);

                    queue.Enqueue(Tuple.Create(current, currentCommand));
                }
            }


            /*
            //Testing command hierarchy
            var topCommandBuilder = commandBuilder.Parents.LastOrDefault() ?? commandBuilder;
            var queue2 = new Queue<CliCommandBuilder>();
            queue2.Enqueue(topCommandBuilder);
            while (queue2.Count > 0)
            {
                var current = queue2.Dequeue();

                var depth = current.Parents.Count();
                Console.Write(new string(' ', 2 * depth));
                Console.WriteLine($@"{current.DefinitionType.Name} (depth: {depth})");

                foreach (var child in current.Children)
                {
                    queue2.Enqueue(child);
                }
            }
            */

            return command;
        }

        /// <summary>
        /// Builds a <see cref="Command"/> instance by inheriting parent settings, populated with directives, options, arguments and settings.
        /// </summary>
        /// <returns>A populated <see cref="Command"/> instance.</returns>
        public Command BuildWithParent(CliCommandBuilder parent)
        {
            if (parent == null) //if no parent, treat as single command build
                return Build(); 

            //Should be before Build
            //Inherit settings from a parent command builder.
            //If a setting is not null in this command builder, then that will be used instead.
            Namer = new CliNamer
            (
                NameAutoGenerate ?? parent.NameAutoGenerate,
                NameCasingConvention ?? parent.NameCasingConvention,
                NamePrefixConvention ?? parent.NamePrefixConvention,
                ShortFormAutoGenerate ?? parent.ShortFormAutoGenerate,
                ShortFormPrefixConvention ?? parent.ShortFormPrefixConvention,
                parent.Namer //Use the parent namer to check names and aliases of sub-commands.
            );

            return DoBuild();
        }

        /// <summary>
        /// Builds a <see cref="Command"/> instance, populated with directives, options, arguments and settings.
        /// </summary>
        /// <returns>A populated <see cref="Command"/> instance.</returns>
        public Command Build()
        {
            Namer = new CliNamer
            (
                NameAutoGenerate,
                NameCasingConvention,
                NamePrefixConvention,
                ShortFormAutoGenerate,
                ShortFormPrefixConvention
            );

            return DoBuild();
        }

        /// <summary>
        /// Builds a <see cref="Command"/> instance, populated with directives, options, arguments and settings.
        /// </summary>
        /// <returns>A populated <see cref="Command"/> instance.</returns>
        protected abstract Command DoBuild();

        /// <summary>
        /// Creates a new instance of the command definition class and binds/populates the properties from the parse result.
        /// Note that binding will be done only once, so calling this method consecutively will return the cached result.
        /// <para>
        /// If the command line input is not for this definition class (e.g. it's for a sub-command but not for
        /// this root command or vice versa), then the returned instance would be empty (i.e. properties would have default values).
        /// </para>
        /// </summary>
        /// <param name="parseResult">A parse result describing the outcome of the parse operation.</param>
        /// <returns>An instance of the definition class whose properties were bound/populated from the parse result.</returns>
        public object Bind(ParseResult parseResult)
        {
            return bindResults.GetOrAdd(parseResult, pr =>
            {
                if (Binder == null)
                    throw new Exception("Binder is not set. Ensure Build method is called first.");

                return Binder(pr);
            });
        }

        /// <summary>
        /// Registers this command builder so that it can be found by the definition class,
        /// and it can be found by the parent definition class if it's a nested/external child.
        /// </summary>
        public void Register()
        {
            if (DefinitionType != null)
                Register(DefinitionType, this);

            if (ParentDefinitionType != null)
                RegisterAsChild(ParentDefinitionType, DefinitionType);

            if (ChildDefinitionTypes != null)
                foreach (var childDefinitionType in ChildDefinitionTypes)
                {
                    if (childDefinitionType != null)
                        RegisterAsChild(DefinitionType, childDefinitionType);
                }
        }


        #region Static

        private static readonly Dictionary<Type, CliCommandBuilder> RegisteredCommandBuilders = new();

        private static readonly Dictionary<Type, HashSet<Type>> RegisteredParentMap = new();

        private static readonly Dictionary<Type, Type> RegisteredChildMap = new();

        /// <summary>
        /// Registers a command builder so that it can be found by the definition class.
        /// </summary>
        /// <param name="commandBuilder">A command builder which builds a <see cref="Command"/>.</param>
        /// <typeparam name="TDefinition">The definition class.</typeparam>
        public static void Register<TDefinition>(CliCommandBuilder commandBuilder)
        {
            var definitionType = typeof(TDefinition);

            Register(definitionType, commandBuilder);
        }

        /// <summary>
        /// Registers a command builder so that it can be found by the definition class.
        /// </summary>
        /// <param name="definitionType">The type of the definition class.</param>
        /// <param name="commandBuilder">A command builder which builds a <see cref="Command"/>.</param>
        public static void Register(Type definitionType, CliCommandBuilder commandBuilder)
        {
            RegisteredCommandBuilders[definitionType] = commandBuilder;
        }

        /// <summary>
        /// Gets the command builder registered for the definition class.
        /// </summary>
        /// <typeparam name="TDefinition">The definition class.</typeparam>
        /// <returns>The registered <see cref="CliCommandBuilder" /> instance.</returns>
        public static CliCommandBuilder Get<TDefinition>()
        {
            var definitionType = typeof(TDefinition);

            return Get(definitionType);
        }

        /// <summary>
        /// Gets the command builder registered for the definition class.
        /// </summary>
        /// <param name="definitionType">The type of the definition class.</param>
        /// <returns>The registered <see cref="CliCommandBuilder" /> instance.</returns>
        public static CliCommandBuilder Get(Type definitionType)
        {
            if (!RegisteredCommandBuilders.TryGetValue(definitionType, out var commandBuilder))
            {
                if (definitionType.GetCustomAttribute<CliCommandAttribute>() == null)
                    throw new Exception($"The class '{definitionType.Name}' should have [CliCommand] attribute.");

                var parentWithoutAttribute = definitionType.WhileNotNull(t => t.DeclaringType)
                    .FirstOrDefault(t => t.GetCustomAttribute<CliCommandAttribute>() == null);
                if (parentWithoutAttribute != null) //nested
                    throw new Exception($"The parent class '{parentWithoutAttribute.Name}' of nested class '{definitionType.Name}' should have [CliCommand] attribute.");


                throw new Exception($"A registered command builder is not found for '{definitionType.Name}'. " +
                                    $"Please ensure the source generator is running and generating a command builder for your definition class.");
            }

            return commandBuilder;
        }

        /// <summary>
        /// Registers a command builder as a nested/external child so that it can be found by the parent definition class.
        /// </summary>
        /// <typeparam name="TParentDefinition">The parent definition class.</typeparam>
        /// <typeparam name="TChildDefinition">The child definition class.</typeparam>
        public static void RegisterAsChild<TParentDefinition, TChildDefinition>()
        {
            var parentDefinitionType = typeof(TParentDefinition);
            var childDefinitionType = typeof(TChildDefinition);

            RegisterAsChild(parentDefinitionType, childDefinitionType);
        }

        /// <summary>
        /// Registers a command builder as a nested/external child so that it can be found by the parent definition class.
        /// </summary>
        /// <param name="parentDefinitionType">The type of the parent definition class.</param>
        /// <param name="childDefinitionType">The type of the child definition class.</param>
        public static void RegisterAsChild(Type parentDefinitionType, Type childDefinitionType)
        {
            if (!RegisteredParentMap.TryGetValue(parentDefinitionType, out var children))
                RegisteredParentMap[parentDefinitionType] = children = new HashSet<Type>();

            children.Add(childDefinitionType);

            if (!RegisteredChildMap.ContainsKey(childDefinitionType))
                RegisteredChildMap.Add(childDefinitionType, parentDefinitionType);

            /*
            if (childCommandBuilder.ParentDefinitionType != null)
            {
                if (RegisteredDefinitionTypes.TryGetValue(childCommandBuilder.ParentDefinitionType, out var parent))
                    RegisteredParentDefinitionTypes[childCommandBuilder.DefinitionType] = parent;
            }
            */
        }

        /// <summary>
        /// Gets the command builders that are registered as nested/external children of a parent definition.
        /// </summary>
        /// <typeparam name="TParentDefinition">The parent definition class.</typeparam>
        /// <returns>An enumerable whose elements are the <see cref="CliCommandBuilder" /> instances registered as nested/external children.</returns>
        public static IEnumerable<CliCommandBuilder> GetChildren<TParentDefinition>()
        {
            var parentDefinitionType = typeof(TParentDefinition);

            return GetChildren(parentDefinitionType);
        }

        /// <summary>
        /// Gets the command builders that are registered as nested/external children of a parent definition.
        /// </summary>
        /// <param name="parentDefinitionType">The type of the parent definition class.</param>
        /// <returns>An enumerable whose elements are the <see cref="CliCommandBuilder" /> instances registered as nested/external children.</returns>
        public static IEnumerable<CliCommandBuilder> GetChildren(Type parentDefinitionType)
        {
            if (parentDefinitionType != null
                && RegisteredParentMap.TryGetValue(parentDefinitionType, out var children))
            {
                foreach (var child in children)
                {
                    if (RegisteredCommandBuilders.TryGetValue(child, out var childCommandBuilder))
                        yield return childCommandBuilder;
                }
            }
        }

        /// <summary>
        /// Gets the command builders that are registered as nested/external parents of a child definition.
        /// </summary>
        /// <typeparam name="TDefinition">The child definition class.</typeparam>
        /// <returns>An enumerable whose elements are the <see cref="CliCommandBuilder" /> instances registered as nested/external parents.</returns>
        public static IEnumerable<CliCommandBuilder> GetParents<TDefinition>()
        {
            var definitionType = typeof(TDefinition);

            return GetParents(definitionType);
        }


        /// <summary>
        /// Gets the command builders that are registered as nested/external parents of a child definition.
        /// </summary>
        /// <param name="definitionType">The type of the child definition class.</param>
        /// <returns>An enumerable whose elements are the <see cref="CliCommandBuilder" /> instances registered as nested/external parents.</returns>
        public static IEnumerable<CliCommandBuilder> GetParents(Type definitionType)
        {
            while (definitionType != null)
            {
                if (RegisteredCommandBuilders.TryGetValue(definitionType, out var commandBuilder)
                    && commandBuilder.ParentDefinitionType != null
                    && RegisteredParentMap.TryGetValue(commandBuilder.ParentDefinitionType, out var children)
                    && children.Contains(commandBuilder.DefinitionType)
                    && RegisteredCommandBuilders.TryGetValue(commandBuilder.ParentDefinitionType, out var parentCommandBuilder))
                {
                    yield return parentCommandBuilder;

                    definitionType = parentCommandBuilder.DefinitionType;
                }
                else
                    yield break;
            }
        }

        /// <summary>
        /// Gets an argument parser method for an argument type, if it's a collection type.
        /// <para>
        /// This is mainly used for adding support for all <see cref="IEnumerable{T}"/> compatible types which have
        /// a public constructor with a <see cref="IEnumerable{T}"/> or <see cref="IList{T}"/> parameter (other parameters, if any, should be optional).
        /// </para>
        /// </summary>
        /// <param name="convertFromArray">A delegate which creates an instance of collection type from an array.</param>
        /// <param name="convertFromString">A delegate which creates an instance of item type from a string.</param>
        /// <typeparam name="TCollection">The collection type, the argument type itself.</typeparam>
        /// <typeparam name="TItem">The item type, e.g. if argument type is IEnumerable&lt;T&gt;, item type will be T.</typeparam>
        /// <returns>A delegate which can be passed to an option or argument.</returns>
        public static Func<ArgumentResult, TCollection> GetArgumentParser<TCollection, TItem>(Func<Array, TCollection> convertFromArray, Func<string, TItem> convertFromString = null)
        {
            ArgumentConverter.RegisterCollectionConverter(convertFromArray);
            ArgumentConverter.RegisterStringConverter(convertFromString);

            return GetArgumentParser<TCollection>();
        }


        /// <summary>
        /// Gets an argument parser method for an argument type.
        /// <para>
        /// This is mainly used for adding support for binding custom types which have a public constructor
        /// or a static <c>Parse</c> method with a string parameter (other parameters, if any, should be optional).
        /// </para>
        /// </summary>
        /// <param name="convertFromString">A delegate which creates an instance of custom type from a string.</param>
        /// <typeparam name="TArgument">The argument type.</typeparam>
        /// <returns>A delegate which can be passed to an option or argument.</returns>
        public static Func<ArgumentResult, TArgument> GetArgumentParser<TArgument>(Func<string, TArgument> convertFromString = null)
        {
            ArgumentConverter.RegisterStringConverter(convertFromString);

            return (result) =>
            {
                var tryConvertArgument = ArgumentConverter.GetConverter(result.Argument);

                if (tryConvertArgument == null)
                {
                    result.AddError($"No argument converter found for type '{result.Argument.ValueType}'");
                    return default; // Ignored.
                }

                tryConvertArgument(result, out var value);

                return value != null
                    ? (TArgument)value
                    : default;
            };
        }

        /// <summary>
        /// Gets the parsed or default value for the specified directive.
        /// <para>
        /// Extended version for DotMake CLI which can bind custom classes,
        /// does not fall back to internal ArgumentConverter.GetDefaultValue which does not support all IList compatible types.
        /// </para>
        /// </summary>
        /// <param name="parseResult">The parse result.</param>
        /// <param name="directive">The directive for which to get a value.</param>
        /// <typeparam name="T">The option type.</typeparam>
        /// <returns>The parsed value or a configured default.</returns>
        public static T GetValueForDirective<T>(ParseResult parseResult, Directive directive)
        {
            var result = parseResult.GetResult(directive);
            if (result != null)
            {
                var type = typeof(T).GetNullableUnderlyingTypeOrSelf();
                if (type == typeof(bool))
                    return (T)(object)true;
                if (type == typeof(string))
                    return (T)(object)(result.Values.FirstOrDefault() ?? string.Empty);
                if (type == typeof(string[]))
                    return (T)(object)result.Values.ToArray();

                throw new Exception("Currently only 'bool', 'string' and 'string[]' types are supported for [CliDirective] properties.");
            }

            return (T)ArgumentConverter.GetDefaultValue(typeof(T));
        }

        /// <inheritdoc cref="GetValueForOption{T}"/>
        public static object GetValueForDirective(ParseResult parseResult, Directive directive)
        {
            /*
            var result = parseResult.GetResult(directive);
            if (result != null)
            {
                var value = result.GetValueOrDefault<object>();
                if (value != null)
                    return value;
            }

            return ArgumentConverter.GetDefaultValue(directive.GetArgument().ValueType);
            */
            return GetValueForDirective<object>(parseResult, directive);
        }

        /// <summary>
        /// Gets the parsed or default value for the specified option.
        /// <para>
        /// Extended version for DotMake CLI which can bind custom classes,
        /// does not fall back to internal ArgumentConverter.GetDefaultValue which does not support all IList compatible types.
        /// </para>
        /// </summary>
        /// <param name="parseResult">The parse result.</param>
        /// <param name="option">The option for which to get a value.</param>
        /// <typeparam name="T">The option type.</typeparam>
        /// <returns>The parsed value or a configured default.</returns>
        public static T GetValueForOption<T>(ParseResult parseResult, Option<T> option)
        {
            var result = parseResult.GetResult(option);
            if (result != null)
            {
                var value = result.GetValueOrDefault<T>();
                if (value != null)
                    return value;
            }

            return (T)ArgumentConverter.GetDefaultValue(typeof(T));
        }

        /// <inheritdoc cref="GetValueForOption{T}"/>
        public static object GetValueForOption(ParseResult parseResult, Option option)
        {
            var result = parseResult.GetResult(option);
            if (result != null)
            {
                var value = result.GetValueOrDefault<object>();
                if (value != null)
                    return value;
            }

            return ArgumentConverter.GetDefaultValue(option.GetArgument().ValueType);
        }

        /// <summary>
        /// Gets the parsed or default value for the specified argument.
        /// <para>
        /// Extended version for DotMake CLI which can bind custom classes,
        /// does not fall back to internal ArgumentConverter.GetDefaultValue which does not support all IList compatible types.
        /// </para>
        /// </summary>
        /// <param name="parseResult">The parse result.</param>
        /// <param name="argument">The argument for which to get a value.</param>
        /// <typeparam name="T">The argument type.</typeparam>
        /// <returns>The parsed value or a configured default.</returns>
        public static T GetValueForArgument<T>(ParseResult parseResult, Argument<T> argument)
        {
            var result = parseResult.GetResult(argument);
            if (result != null)
            {
                var value = result.GetValueOrDefault<T>();
                if (value != null)
                    return value;
            }

            return (T)ArgumentConverter.GetDefaultValue(typeof(T));
        }

        /// <inheritdoc cref="GetValueForArgument{T}"/>
        public static object GetValueForArgument(ParseResult parseResult, Argument argument)
        {
            var result = parseResult.GetResult(argument);
            if (result != null)
            {
                var value = result.GetValueOrDefault<object>();
                if (value != null)
                    return value;
            }

            return ArgumentConverter.GetDefaultValue(argument.ValueType);
        }

        #endregion
    }
}
