using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.CommandLine;
using System.CommandLine.Parsing;
using System.Linq;
using System.Reflection;
using DotMake.CommandLine.Binding;

namespace DotMake.CommandLine
{
    /// <summary>
    /// Represents a command builder generated by the source generator.
    /// </summary>
    public abstract class CliCommandBuilder
    {
        private readonly ConcurrentDictionary<ParseResult, object> bindResults = new();
        private readonly HashSet<string> usedAliases = new(StringComparer.Ordinal);
        private readonly CliCommandAttribute defaults = CliCommandAttribute.Default;

        /// <summary>
        /// A delegate which is set by the source generator to be called from <see cref="Bind(ParseResult)"/> method.
        /// </summary>
        protected Func<ParseResult, object> Binder;

        /// <summary>
        /// The service provider if it is used. This will be disposed at the end of the execution.
        /// </summary>
        protected IServiceProvider ServiceProvider;


        /// <summary>
        /// Initializes a new instance of the <see cref="CliCommandBuilder" /> class.
        /// </summary>
        protected CliCommandBuilder()
        {
        }

        /// <summary>
        /// The definition class that this command builder is generated for.
        /// </summary>
        public Type DefinitionType { get; protected set; }

        /// <summary>
        /// The parent definition class if this command builder is generated for a nested/external child.
        /// </summary>
        public Type ParentDefinitionType { get; protected set; }

        /// <summary>
        /// The child definition classes if this command builder is generated for an external parent.
        /// </summary>
        public Type[] ChildDefinitionTypes { get; protected set; }

        /// <summary>
        /// Gets the character casing convention used for automatically generated command, option and argument names.
        /// </summary>
        public CliNameCasingConvention? NameCasingConvention { get; protected set; }

        /// <summary>
        /// Gets the prefix convention used for automatically generated option names.
        /// </summary>
        public CliNamePrefixConvention? NamePrefixConvention { get; protected set; }

        /// <summary>
        /// Gets the prefix convention used for automatically generated short form option aliases.
        /// </summary>
        public CliNamePrefixConvention? ShortFormPrefixConvention { get; protected set; }

        /// <summary>
        /// Gets a value which indicates whether short form aliases were automatically generated for options.
        /// </summary>
        public bool? ShortFormAutoGenerate { get; protected set; }

        /// <summary>
        /// Gets the command builders that are nested/external children of this command builder.
        /// </summary>
        public IEnumerable<CliCommandBuilder> Children => GetChildren(DefinitionType);

        /// <summary>
        /// Gets the command builders that are nested/external parents of this command builder.
        /// </summary>
        public IEnumerable<CliCommandBuilder> Parents => GetParents(DefinitionType);

        /// <summary>
        /// Gets a value which indicates whether this command builder is for a root command.
        /// </summary>
        public bool IsRoot => !RegisteredChildMap.ContainsKey(DefinitionType);

        /// <summary>
        /// Builds a <see cref="Command"/> instance, populated with sub-commands, options, arguments and settings.
        /// </summary>
        /// <returns>A populated <see cref="Command"/> instance.</returns>
        public abstract Command Build();

        /// <summary>
        /// Creates a new instance of the command definition class and binds/populates the properties from the parse result.
        /// Note that binding will be done only once, so calling this method consecutively will return the cached result.
        /// <para>
        /// If the command line input is not for this definition class (e.g. it's for a sub-command but not for
        /// this root command or vice versa), then the returned instance would be empty (i.e. properties would have default values).
        /// </para>
        /// </summary>
        /// <param name="parseResult">A parse result describing the outcome of the parse operation.</param>
        /// <returns>An instance of the definition class whose properties were bound/populated from the parse result.</returns>
        public object Bind(ParseResult parseResult)
        {
            return bindResults.GetOrAdd(parseResult, pr =>
            {
                if (Binder == null)
                    throw new Exception("Binder is not set. Ensure Build method is called first.");

                return Binder(pr);
            });
        }

        /// <summary>
        /// Registers this command builder so that it can be found by the definition class,
        /// and it can be found by the parent definition class if it's a nested/external child.
        /// </summary>
        public void Register()
        {
            if (DefinitionType != null)
                Register(DefinitionType, this);

            if (ParentDefinitionType != null)
                RegisterAsChild(ParentDefinitionType, DefinitionType);

            if (ChildDefinitionTypes != null)
                foreach (var childDefinitionType in ChildDefinitionTypes)
                {
                    if (childDefinitionType != null)
                        RegisterAsChild(DefinitionType, childDefinitionType);
                }

        }

        /// <summary>
        /// Inherits settings from a parent command builder.
        /// If a setting is not null in this command builder, then that will be used instead.
        /// </summary>
        public void InheritSettings(CliCommandBuilder parent)
        {
            if (parent == null)
                return;

            NameCasingConvention ??= parent.NameCasingConvention;
            NamePrefixConvention ??= parent.NamePrefixConvention;
            ShortFormPrefixConvention ??= parent.ShortFormPrefixConvention;
            ShortFormAutoGenerate ??= parent.ShortFormAutoGenerate;
        }

        /// <summary>
        /// Gets the command name for a property by using current <see cref="NameCasingConvention"/>.
        /// </summary>
        public string GetCommandName(string commandName)
        {
            return commandName.ToCase(NameCasingConvention ?? defaults.NameCasingConvention);
        }

        /// <summary>
        /// Gets the argument name for a property by using current <see cref="NameCasingConvention"/>.
        /// </summary>
        public string GetArgumentName(string propertyName)
        {
            return propertyName.ToCase(NameCasingConvention ?? defaults.NameCasingConvention);
        }

        /// <summary>
        /// Gets the option name for a property by using current <see cref="NameCasingConvention"/> and <see cref="NamePrefixConvention"/>.
        /// </summary>
        public string GetOptionName(string propertyName)
        {
            return propertyName.ToCase(NameCasingConvention ?? defaults.NameCasingConvention)
                .AddPrefix(NamePrefixConvention ?? defaults.NamePrefixConvention);
        }

        /// <summary>
        /// Adds an alias to an option. Tracks used aliases and only adds if not already used.
        /// </summary>
        public void AddAlias(Option option, string alias)
        {
            if (!string.IsNullOrWhiteSpace(alias) && !usedAliases.Contains(alias))
            {
                option.Aliases.Add(alias);
                usedAliases.Add(alias);
            }
        }

        /// <summary>
        /// Adds an alias to a command. Tracks used aliases and only adds if not already used.
        /// </summary>
        public void AddAlias(Command command, string alias)
        {
            if (!string.IsNullOrWhiteSpace(alias) && !usedAliases.Contains(alias))
            {
                command.Aliases.Add(alias);
                usedAliases.Add(alias);
            }
        }

        /// <summary>
        /// Adds a short form alias for an option name for a property by using current <see cref="ShortFormAutoGenerate"/> and <see cref="ShortFormPrefixConvention"/>.
        /// Short form alias is added only when current <see cref="ShortFormAutoGenerate"/> is <see langword="true"/> and option name without prefix is longer than 1 character.
        /// </summary>
        public void AddShortFormAlias(Option option)
        {
            var optionNameWithoutPrefix = option.Name.RemovePrefix();

            if ((ShortFormAutoGenerate ?? defaults.ShortFormAutoGenerate)
                && optionNameWithoutPrefix.Length > 1)
            {
                var shortForm = optionNameWithoutPrefix[0]
                    .ToString()
                    .AddPrefix(ShortFormPrefixConvention ?? defaults.ShortFormPrefixConvention);

                AddAlias(option, shortForm);
            }
        }



        #region Static

        private static readonly Dictionary<Type, CliCommandBuilder> RegisteredCommandBuilders = new();

        private static readonly Dictionary<Type, HashSet<Type>> RegisteredParentMap = new();

        private static readonly Dictionary<Type, Type> RegisteredChildMap = new();

        /// <summary>
        /// Registers a command builder so that it can be found by the definition class.
        /// </summary>
        /// <param name="commandBuilder">A command builder which builds a <see cref="Command"/>.</param>
        /// <typeparam name="TDefinition">The definition class.</typeparam>
        public static void Register<TDefinition>(CliCommandBuilder commandBuilder)
        {
            var definitionType = typeof(TDefinition);

            Register(definitionType, commandBuilder);
        }

        /// <summary>
        /// Registers a command builder so that it can be found by the definition class.
        /// </summary>
        /// <param name="definitionType">The type of the definition class.</param>
        /// <param name="commandBuilder">A command builder which builds a <see cref="Command"/>.</param>
        public static void Register(Type definitionType, CliCommandBuilder commandBuilder)
        {
            RegisteredCommandBuilders[definitionType] = commandBuilder;
        }

        /// <summary>
        /// Gets the command builder registered for the definition class.
        /// </summary>
        /// <typeparam name="TDefinition">The definition class.</typeparam>
        /// <returns>The registered <see cref="CliCommandBuilder" /> instance.</returns>
        public static CliCommandBuilder Get<TDefinition>()
        {
            var definitionType = typeof(TDefinition);

            return Get(definitionType);
        }

        /// <summary>
        /// Gets the command builder registered for the definition class.
        /// </summary>
        /// <param name="definitionType">The type of the definition class.</param>
        /// <returns>The registered <see cref="CliCommandBuilder" /> instance.</returns>
        public static CliCommandBuilder Get(Type definitionType)
        {
            if (!RegisteredCommandBuilders.TryGetValue(definitionType, out var commandBuilder))
            {
                if (definitionType.GetCustomAttribute<CliCommandAttribute>() == null)
                    throw new Exception($"The class '{definitionType.Name}' should have [CliCommand] attribute.");

                var parentWithoutAttribute = definitionType.RecurseWhileNotNull(t => t.DeclaringType)
                    .FirstOrDefault(t => t.GetCustomAttribute<CliCommandAttribute>() == null);
                if (parentWithoutAttribute != null) //nested
                    throw new Exception($"The parent class '{parentWithoutAttribute.Name}' of nested class '{definitionType.Name}' should have [CliCommand] attribute.");


                throw new Exception($"A registered command builder is not found for '{definitionType.Name}'. " +
                                    $"Please ensure the source generator is running and generating a command builder for your definition class.");
            }

            return commandBuilder;
        }

        /// <summary>
        /// Registers a command builder as a nested/external child so that it can be found by the parent definition class.
        /// </summary>
        /// <typeparam name="TParentDefinition">The parent definition class.</typeparam>
        /// <typeparam name="TChildDefinition">The child definition class.</typeparam>
        public static void RegisterAsChild<TParentDefinition, TChildDefinition>()
        {
            var parentDefinitionType = typeof(TParentDefinition);
            var childDefinitionType = typeof(TChildDefinition);

            RegisterAsChild(parentDefinitionType, childDefinitionType);
        }

        /// <summary>
        /// Registers a command builder as a nested/external child so that it can be found by the parent definition class.
        /// </summary>
        /// <param name="parentDefinitionType">The type of the parent definition class.</param>
        /// <param name="childDefinitionType">The type of the child definition class.</param>
        public static void RegisterAsChild(Type parentDefinitionType, Type childDefinitionType)
        {
            if (!RegisteredParentMap.TryGetValue(parentDefinitionType, out var children))
                RegisteredParentMap[parentDefinitionType] = children = new HashSet<Type>();

            children.Add(childDefinitionType);

            if (!RegisteredChildMap.ContainsKey(childDefinitionType))
                RegisteredChildMap.Add(childDefinitionType, parentDefinitionType);

            /*
            if (childCommandBuilder.ParentDefinitionType != null)
            {
                if (RegisteredDefinitionTypes.TryGetValue(childCommandBuilder.ParentDefinitionType, out var parent))
                    RegisteredParentDefinitionTypes[childCommandBuilder.DefinitionType] = parent;
            }
            */
        }

        /// <summary>
        /// Gets the command builders that are registered as nested/external children of a parent definition.
        /// </summary>
        /// <typeparam name="TParentDefinition">The parent definition class.</typeparam>
        /// <returns>An enumerable whose elements are the <see cref="CliCommandBuilder" /> instances registered as nested/external children.</returns>
        public static IEnumerable<CliCommandBuilder> GetChildren<TParentDefinition>()
        {
            var parentDefinitionType = typeof(TParentDefinition);

            return GetChildren(parentDefinitionType);
        }

        /// <summary>
        /// Gets the command builders that are registered as nested/external children of a parent definition.
        /// </summary>
        /// <param name="parentDefinitionType">The type of the parent definition class.</param>
        /// <returns>An enumerable whose elements are the <see cref="CliCommandBuilder" /> instances registered as nested/external children.</returns>
        public static IEnumerable<CliCommandBuilder> GetChildren(Type parentDefinitionType)
        {
            if (parentDefinitionType != null
                && RegisteredParentMap.TryGetValue(parentDefinitionType, out var children))
            {
                foreach (var child in children)
                {
                    if (RegisteredCommandBuilders.TryGetValue(child, out var childCommandBuilder))
                        yield return childCommandBuilder;
                }
            }
        }

        /// <summary>
        /// Gets the command builders that are registered as nested/external parents of a child definition.
        /// </summary>
        /// <typeparam name="TDefinition">The child definition class.</typeparam>
        /// <returns>An enumerable whose elements are the <see cref="CliCommandBuilder" /> instances registered as nested/external parents.</returns>
        public static IEnumerable<CliCommandBuilder> GetParents<TDefinition>()
        {
            var definitionType = typeof(TDefinition);

            return GetParents(definitionType);
        }


        /// <summary>
        /// Gets the command builders that are registered as nested/external parents of a child definition.
        /// </summary>
        /// <param name="definitionType">The type of the child definition class.</param>
        /// <returns>An enumerable whose elements are the <see cref="CliCommandBuilder" /> instances registered as nested/external parents.</returns>
        public static IEnumerable<CliCommandBuilder> GetParents(Type definitionType)
        {
            while (definitionType != null)
            {
                if (RegisteredCommandBuilders.TryGetValue(definitionType, out var commandBuilder)
                    && commandBuilder.ParentDefinitionType != null
                    && RegisteredParentMap.TryGetValue(commandBuilder.ParentDefinitionType, out var children)
                    && children.Contains(commandBuilder.DefinitionType)
                    && RegisteredCommandBuilders.TryGetValue(commandBuilder.ParentDefinitionType, out var parentCommandBuilder))
                {
                    yield return parentCommandBuilder;

                    definitionType = parentCommandBuilder.ParentDefinitionType;
                }
                else
                    yield break;
            }
        }

        /// <summary>
        /// Gets an argument parser method for an argument type, if it's a collection type.
        /// <para>
        /// This is mainly used for adding support for all <see cref="IEnumerable{T}"/> compatible types which have
        /// a public constructor with a <see cref="IEnumerable{T}"/> or <see cref="IList{T}"/> parameter (other parameters, if any, should be optional).
        /// </para>
        /// </summary>
        /// <param name="convertFromArray">A delegate which creates an instance of collection type from an array.</param>
        /// <param name="convertFromString">A delegate which creates an instance of item type from a string.</param>
        /// <typeparam name="TCollection">The collection type, the argument type itself.</typeparam>
        /// <typeparam name="TItem">The item type, e.g. if argument type is IEnumerable&lt;T&gt;, item type will be T.</typeparam>
        /// <returns>A delegate which can be passed to an option or argument.</returns>
        public static Func<ArgumentResult, TCollection> GetArgumentParser<TCollection, TItem>(Func<Array, TCollection> convertFromArray, Func<string, TItem> convertFromString = null)
        {
            ArgumentConverter.RegisterCollectionConverter(convertFromArray);
            ArgumentConverter.RegisterStringConverter(convertFromString);

            return GetArgumentParser<TCollection>();
        }


        /// <summary>
        /// Gets an argument parser method for an argument type.
        /// <para>
        /// This is mainly used for adding support for binding custom types which have a public constructor
        /// or a static <c>Parse</c> method with a string parameter (other parameters, if any, should be optional).
        /// </para>
        /// </summary>
        /// <param name="convertFromString">A delegate which creates an instance of custom type from a string.</param>
        /// <typeparam name="TArgument">The argument type.</typeparam>
        /// <returns>A delegate which can be passed to an option or argument.</returns>
        public static Func<ArgumentResult, TArgument> GetArgumentParser<TArgument>(Func<string, TArgument> convertFromString = null)
        {
            ArgumentConverter.RegisterStringConverter(convertFromString);

            return (result) =>
            {
                var tryConvertArgument = ArgumentConverter.GetConverter(result.Argument);

                if (tryConvertArgument == null)
                {
                    result.AddError($"No argument converter found for type '{result.Argument.ValueType}'");
                    return default; // Ignored.
                }

                tryConvertArgument(result, out var value);

                return value != null
                    ? (TArgument)value
                    : default;
            };
        }

        /// <summary>
        /// Gets the parsed or default value for the specified option.
        /// <para>
        /// Extended version for DotMake CLI which can bind custom classes,
        /// does not fall back to internal ArgumentConverter.GetDefaultValue which does not support all IList compatible types.
        /// </para>
        /// </summary>
        /// <param name="parseResult">The parse result.</param>
        /// <param name="option">The option for which to get a value.</param>
        /// <typeparam name="T">The option type.</typeparam>
        /// <returns>The parsed value or a configured default.</returns>
        public static T GetValueForOption<T>(ParseResult parseResult, Option<T> option)
        {
            var result = parseResult.GetResult(option);
            if (result != null)
            {
                var value = result.GetValueOrDefault<T>();
                if (value != null)
                    return value;
            }

            return (T)ArgumentConverter.GetDefaultValue(typeof(T));
        }

        /// <inheritdoc cref="GetValueForOption{T}"/>
        public static object GetValueForOption(ParseResult parseResult, Option option)
        {
            var result = parseResult.GetResult(option);
            if (result != null)
            {
                var value = result.GetValueOrDefault<object>();
                if (value != null)
                    return value;
            }

            return ArgumentConverter.GetDefaultValue(option.GetArgument().ValueType);
        }

        /// <summary>
        /// Gets the parsed or default value for the specified argument.
        /// <para>
        /// Extended version for DotMake CLI which can bind custom classes,
        /// does not fall back to internal ArgumentConverter.GetDefaultValue which does not support all IList compatible types.
        /// </para>
        /// </summary>
        /// <param name="parseResult">The parse result.</param>
        /// <param name="argument">The argument for which to get a value.</param>
        /// <typeparam name="T">The argument type.</typeparam>
        /// <returns>The parsed value or a configured default.</returns>
        public static T GetValueForArgument<T>(ParseResult parseResult, Argument<T> argument)
        {
            var result = parseResult.GetResult(argument);
            if (result != null)
            {
                var value = result.GetValueOrDefault<T>();
                if (value != null)
                    return value;
            }

            return (T)ArgumentConverter.GetDefaultValue(typeof(T));
        }

        /// <inheritdoc cref="GetValueForArgument{T}"/>
        public static object GetValueForArgument(ParseResult parseResult, Argument argument)
        {
            var result = parseResult.GetResult(argument);
            if (result != null)
            {
                var value = result.GetValueOrDefault<object>();
                if (value != null)
                    return value;
            }

            return ArgumentConverter.GetDefaultValue(argument.ValueType);
        }

        #endregion
    }
}
