<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>net8.0;netstandard2.0</TargetFrameworks>
    <LangVersion>10.0</LangVersion>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>

    <!--
      IsTrimmable to enable trim warnings
      https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/prepare-libraries-for-trimming?pivots=dotnet-6-0#enable-project-specific-trimming    

      IsAotCompatible to enable trim warnings (also enables IsTrimmable but it's only for net.8.0)
      https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/?tabs=net8plus%2Cwindows#aot-compatibility-analyzers
    -->
    <IsTrimmable Condition="$([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'net6.0'))">true</IsTrimmable>
    <IsAotCompatible Condition="$([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'net7.0'))">true</IsAotCompatible>

    <!-- NuGet Package Information (common ones are in Directory.Build.props) -->
    <!-- Description is used for assembly and NuGet metadata -->
    <Description>Declarative syntax for System.CommandLine via attributes for easy, fast, strongly-typed (no reflection) usage. Includes a source generator which automagically converts your classes to CLI commands and properties to CLI options or CLI arguments.</Description>
    <PackageTags>command-line CLI console System.CommandLine declarative attributes parsing command argument option generator</PackageTags>
    <PackageReleaseNotes>
      <![CDATA[
        - Changed: Renamed `Cli.GetConfiguration()` to `Cli.GetParser()` and changed return type from `CommandLineConfiguration`
          to new class `CliParser`.
          This method returns a CLI parser configured for the indicated command and you can call `Parse` or `Run` methods on it.
          So you can reuse the same `CliParser` for parsing and running.
          ```c#
          var parser = Cli.GetParser<RootCliCommand>();
          
          var result = parser.Parse(args);
          
          parser.Run(args);
          ```

          Changed return type of `Cli.Parse` methods from `ParseResult` to new class `CliResult` which
          describes the results of parsing a command line input based on a specific parser configuration
          and provides methods for binding the result to definition classes.
          ```c#
          var result = Cli.Parse<RootCliCommand>(args);

          var rootCliCommand = result.Bind<RootCliCommand>();
          
          if (result.ParseResult.Errors.Count > 0)
          {
          }
          ```
          
        - Improved: More robust command binding. Introduced `CliBindingContext` for internally encapsulating binders per command build and configuration.
          For example, in previous versions, the below code worked incorrectly, i.e. second call to `Cli.Parse` with same definition type,
          overwrote the binder so the later `Bind` call did not work correctly.
          ```c#
          var result = Cli.Parse<RootCliCommand>(args);
          var result2 = Cli.Parse<RootCliCommand>(args);
          
          var rootCommand = result.Bind<RootCliCommand>();
          ```
      ]]>
     </PackageReleaseNotes>
  </PropertyGroup>

  <Import Project="..\DotMake.CommandLine.Shared\DotMake.CommandLine.Shared.projitems" Label="Shared" />

  <ItemGroup>
    <PackageReference Include="System.CommandLine" Version="2.0.0-beta5.25306.1" />

    <!--
      UPDATE: No longer using this as now 2.0.0-beta5.25306.1 is released to official nuget feed.
      Using the latest version package published on DotNet Daily Builds feed (package source defined in src/nuget.config),
      as it's not on official nuget feed, we directly reference the DLL inside the package so that it's also bundled in our package.

      So we have <PackageReference> with ExcludeAssets="All" so that the package reference is not added as a nuget dependency
      in our NuGet package, and with GeneratePathProperty="true" so that we can use <Reference> to reference the DLL from
      the package directly with HintPath. Finally, we have <None> item with Pack="true" to pack all DLLs named System.CommandLine*
      in our NuGet package.
      https://blog.maartenballiauw.be/post/2020/04/22/referencing-specific-assembly-nuget-package.html
    -->
    <!--
    <PackageReference Include="System.CommandLine" Version="2.0.0-beta5.25302.104">
      <GeneratePathProperty>true</GeneratePathProperty>
      <IncludeAssets>None</IncludeAssets>
      <ExcludeAssets>All</ExcludeAssets>
      <PrivateAssets>None</PrivateAssets>
    </PackageReference>
    <PackageReference Include="System.Memory" version="4.5.4" Condition="'$(TargetFramework)' == 'netstandard2.0'" />
    <Reference Include="System.CommandLine">
      <HintPath>$(PkgSystem_CommandLine)\lib\$(TargetFramework)\System.CommandLine.dll</HintPath>
    </Reference>
    <None Include="$(OutputPath)\$(TargetFramework)\**\System.CommandLine*" Pack="true" PackagePath="lib/$(TargetFramework)" Visible="false" />
    -->
  </ItemGroup>

  <ItemGroup>
    <!-- 
      https://github.com/dotnet/roslyn/issues/55229 
      https://stackoverflow.com/a/69193922
    -->
    <!-- Ensure that the source generator is built together with this project -->
    <ProjectReference Include="..\$(MSBuildProjectName).SourceGeneration\$(MSBuildProjectName).SourceGeneration.csproj">
      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
    </ProjectReference>
    <!-- Package the generator in the analyzer directory of the nuget package -->
    <None Include="..\$(MSBuildProjectName).SourceGeneration\$(OutputPath)\netstandard2.0\*.dll" Pack="true" PackagePath="analyzers/dotnet/cs" Visible="false" />
    <!--
      Package MSBuild .props file in the nuget package
      https://learn.microsoft.com/en-us/nuget/concepts/msbuild-props-and-targets
    -->
    <None Include="nuget.props" Pack="true" PackagePath="build/$(PackageId).props" Visible="false" />
  </ItemGroup>

  <ItemGroup>
    <None Remove="*.DotSettings" />
  </ItemGroup>

</Project>
