using System.Collections.Generic;
using System;
using System.Linq;
using System.Reflection;
using System.Text;

namespace DotMake.CommandLine
{
    /// <summary>
    /// Represents a definition class generated by the source generator for a command as delegate.
    /// </summary>
    public class CliCommandAsDelegateDefinition
    {
        /// <summary>
        /// Invokes the method represented by the command as delegate.
        /// </summary>
        /// <param name="hash">The hash for command as delegate.</param>
        /// <param name="args">
        /// An array of objects that are the arguments to pass to the method represented
        /// by the command as delegate. -or- null, if the method represented
        /// by the command as delegate does not require arguments.
        /// </param>
        /// <returns>The object returned by the method represented by the delegate.</returns>
        public object InvokeDelegate(string hash, object[] args)
        {
            if (!RegisteredDelegates.TryGetValue(hash, out var delegateInstance))
                throw new Exception($"A registered command as delegate instance is not found for hash '{hash}'. " +
                                    $"Please ensure CliCommandAsDelegateDefinition.Get() is called first.");

            return delegateInstance.DynamicInvoke(args);
        }

        #region Static

        private static readonly Dictionary<string, Type> RegisteredDefinitionTypes = new Dictionary<string, Type>();
        private static readonly Dictionary<string, Delegate> RegisteredDelegates = new Dictionary<string, Delegate>();

        /// <summary>
        /// Registers a definition class so that it can be found by the hash of command as delegate.
        /// </summary>
        /// <param name="hash">The hash of command as delegate.</param>
        /// <typeparam name="TDefinition">The definition class.</typeparam>
        public static void Register<TDefinition>(string hash)
        {
            var definitionType = typeof(TDefinition);

            RegisteredDefinitionTypes[hash] = definitionType;
        }

        /// <summary>
        /// Gets the definition class registered for a command as delegate.
        /// Also registers the delegate instance so that it can be found by the hash.
        /// </summary>
        /// <param name="cliCommandAsDelegate">The command as delegate.</param>
        /// <returns>The registered type of definition class.</returns>
        public static Type Get(Delegate cliCommandAsDelegate)
        {
            var hash = GenerateHash(cliCommandAsDelegate);

            if (!RegisteredDefinitionTypes.TryGetValue(hash, out var definitionType))
                throw new Exception($"A registered definition class is not found for command as delegate hash '{hash}'. " +
                                    $"Please ensure the source generator is running and generating a definition class for your command as delegate.");

            RegisteredDelegates[hash] = cliCommandAsDelegate;

            return definitionType;
        }

        private static string GenerateHash(Delegate cliCommandAsDelegate)
        {
            return GenerateString(cliCommandAsDelegate).GetStableStringHashCode32();
        }

        //The generated string should match the one generated in DotMake.CommandLine.SourceGeneration.CliCommandAsDelegateInfo
        //So that the generated hash matches.
        private static string GenerateString(Delegate cliCommandAsDelegate)
        {
            var sb = new StringBuilder();

            AppendMethodData(sb, cliCommandAsDelegate.Method);

            return sb.ToString();
        }

        private static void AppendMethodData(StringBuilder sb, MethodInfo methodInfo)
        {
            AppendAttributeData(sb, methodInfo.CustomAttributes
                .FirstOrDefault(data => data.AttributeType == typeof(CliCommandAttribute))
            );

            sb.AppendLine(methodInfo.ReturnType.ToString());

            foreach (var parameterInfo in methodInfo.GetParameters())
            {
                AppendAttributeData(sb, parameterInfo.CustomAttributes
                    .FirstOrDefault(data => data.AttributeType == typeof(CliOptionAttribute)
                                            || data.AttributeType == typeof(CliArgumentAttribute))
                );

                sb.Append(parameterInfo.ParameterType);
                sb.Append(",");
                sb.Append(parameterInfo.Name);
                sb.Append(",");
                if (parameterInfo.HasDefaultValue)
                    sb.Append(parameterInfo.DefaultValue);
                sb.AppendLine();
            }
        }

        private static void AppendAttributeData(StringBuilder sb, CustomAttributeData attributeData)
        {
            sb.Append("[");

            if (attributeData != null)
            {
                sb.Append($"{attributeData.AttributeType}(");

                if (attributeData.NamedArguments != null)
                    foreach (var namedArgument in attributeData.NamedArguments)
                    {
                        var typedArgument = namedArgument.TypedValue;
                        var value = (typedArgument.Value == null)
                            ? "null"
                            : typedArgument.ArgumentType.IsArray
                                ? string.Join(",", (object[])typedArgument.Value)
                                : typedArgument.Value?.ToString();

                        sb.Append($"{namedArgument.MemberName}=\"{value}\",");
                    }

                sb.Append(")");
            }

            sb.AppendLine("]");
        }

        #endregion
    }
}
