<!DOCTYPE html []><html lang="en-US"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="shortcut icon" href="../icons/favicon.ico" /><link rel="stylesheet" href="../css/bulma.css" /><link rel="stylesheet" href="../css/font-awesome.min.css" /><link rel="stylesheet" href="../css/presentationStyle.css" /><link rel="stylesheet" href="../css/vs.min.css" /><script src="../scripts/jquery-3.5.1.min.js"></script><script src="../scripts/clipboard.min.js"></script><script src="../scripts/highlight.min.js"></script><script src="../scripts/presentationStyle.js"></script><title>CliOptionAttribute Class</title><meta name="Title" content="CliOptionAttribute" /><meta name="Help.Id" content="T:DotMake.CommandLine.CliOptionAttribute" /><meta name="Help.ContentType" content="Reference" /><meta name="container" content="DotMake.CommandLine" /><meta name="guid" content="T_DotMake_CommandLine_CliOptionAttribute" /><meta name="Description" content="Specifies a class property that represents an option which is a named parameter and a value for that parameter, that is used on the command line." /><meta name="tocFile" content="../toc/IDAA.xml" /></head><body><div class="fixedLayout"><div id="Header" class="fixedHeader"><div class="pageHeader level mb-0 py-2 px-4"><div id="TitleContainer" class="level-left"><div class="level-item"><img style="height: 64px;" src="../icons/logo128.png" /></div><div id="DocumentationTitle" class="level-item">DotMake Command-Line Documentation</div></div><div id="LangFilterSearchContainer" class="level-right"><div class="level-item"><div class="dropdown is-hoverable"><div class="dropdown-trigger"><button class="button" aria-haspopup="true" aria-controls="dropdown-menu"><span id="CurrentLanguage"></span><span class="icon is-small"><i class="fa fa-angle-down" aria-hidden="true"></i></span></button></div><div class="dropdown-menu" role="menu"><div id="LanguageSelections" class="dropdown-content"><a class="dropdown-item languageFilterItem" data-languageId="cs">C#</a></div></div></div></div><div class="level-item"><form id="SearchForm" action="#" onsubmit="TransferToSearchPage(); return false;"><div class="field"><div class="control has-icons-left"><input id="SearchTerms" class="input" type="text" maxlength="200" placeholder="Search" /><span class="icon is-small is-left"><i class="fa fa-search"></i></span><button id="SearchButton" type="submit" class="is-hidden"></button></div></div></form></div></div></div></div><div class="fixedContent"><nav class="breadcrumb my-1 px-2 border-bottom" role="navigation"><ul id="TopicBreadcrumbs" /></nav><div id="ContentContainer" class="columns pl-5 pr-5 fixedContent"><div id="ShowHideTOCColumn" class="column is-hidden-tablet"><a id="ShowHideTOC">Show/Hide TOC</a></div><div id="TOCColumn" class="column is-hidden-mobile"><nav class="toc"><ul id="TableOfContents" class="toc-menu" /></nav></div><div id="Resizer" class="is-hidden"></div><div id="TopicContent" class="column content is-7"><h1>Cli<wbr />Option<wbr />Attribute Class</h1><div class="summary">
            Specifies a class property that represents an option which is a named parameter and a value for that parameter, that is used on the command line.
            <div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">[CliOption]
public string SomeCliOption { get; set; }</code></pre></div></div><p>
            Note that an option is required if the decorated property does not have a default value (set via a property initializer),
            see <a href="P_DotMake_CommandLine_CliOptionAttribute_Required.htm">Required</a> property for details.
            </p><p><b>Options:</b> An option is a named parameter that can be passed to a command. The POSIX convention is to prefix the option name with two hyphens (<span class="code">--</span>).
            The following example shows two options:
            <div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">console</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-console">dotnet tool update dotnet-suggest --verbosity quiet --global
                                  ^---------^       ^------^</code></pre></div></div>
            As this example illustrates, the value of the option may be explicit (<span class="code">quiet</span> for <span class="code">--verbosity</span>) or implicit (nothing follows <span class="code">--global</span>).
            Options that have no value specified are typically Boolean parameters that default to <span class="code">true</span> if the option is specified on the command line.
            </p><p>
            For some Windows command-line apps, you identify an option by using a leading slash (<span class="code">/</span>) with the option name. For example:
            <div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">console</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-console">msbuild /version
        ^------^</code></pre></div></div>
            Both POSIX and Windows prefix conventions are supported.
            When manually setting a name (overriding decorated property's name), you should specify the option name including the prefix (e.g. `--option`, `-o`, `-option` or `/option`).
            </p><p>
            Bundling of single-character options are supported, also known as stacking.
            Bundled options are single-character option aliases specified together after a single hyphen prefix.
            For example if you have options "-a", "-b" and "-c", you can bundle them like "-abc".
            Only the last option can specify an argument.
            Note that if you have an explicit option named "-abc" then it will win over bundled options.
            </p></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Definition</h2><div id="IDBSection"><strong>Namespace:</strong> <a href="N_DotMake_CommandLine.htm">DotMake.CommandLine</a><br /><strong>Assembly:</strong> DotMake.CommandLine (in DotMake.CommandLine.dll) Version: 2.5.6<div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><span class="buttons"><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></span></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs"><span class="keyword">public</span> <span class="keyword">class</span> <span class="identifier">CliOptionAttribute</span> : <span class="identifier">Attribute</span></code></pre></div></div><dl class="inheritanceHierarchy"><dt>Inheritance</dt><dd><a href="https://learn.microsoft.com/dotnet/api/system.object" target="_blank" rel="noopener noreferrer">Object</a>  <span class="icon is-small"><i class="fa fa-arrow-right"></i></span>  <a href="https://learn.microsoft.com/dotnet/api/system.attribute" target="_blank" rel="noopener noreferrer">Attribute</a>  <span class="icon is-small"><i class="fa fa-arrow-right"></i></span>  <span class="selflink">CliOptionAttribute</span></dd></dl></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Example</h2><div id="IDBCSection"><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">//Delegate-based model
//In Program.cs, add this simple code:
Cli.Run(([CliArgument] string argument1, bool option1) =&gt;
{
    Console.WriteLine($@"Value for {nameof(argument1)} parameter is '{argument1}'");
    Console.WriteLine($@"Value for {nameof(option1)} parameter is '{option1}'");
});

//Or:
Cli.Run(Method);

void Method([CliArgument] string argument2, bool option2)
{
    Console.WriteLine($@"Value for {nameof(argument2)} parameter is '{argument2}'");
    Console.WriteLine($@"Value for {nameof(option2)} parameter is '{option2}'");
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// Class-based model
// Create a simple class like this:

[CliCommand(Description = "A root cli command")]
public class RootCliCommand
{
    [CliOption(Description = "Description for Option1")]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = "Description for Argument1")]
    public string Argument1 { get; set; }

    public void Run()
    {
        Console.WriteLine($@"Handler for '{GetType().FullName}' is run:");
        Console.WriteLine($@"Value for {nameof(Option1)} property is '{Option1}'");
        Console.WriteLine($@"Value for {nameof(Argument1)} property is '{Argument1}'");
        Console.WriteLine();
    }
}

        //In Program.cs, add this single line:
        Cli.Run&lt;RootCliCommand&gt;(args);

        //If you need to simply parse the command-line arguments without invocation, use this:
        var parseResult = Cli.Parse&lt;RootCliCommand&gt;(args);
        var rootCliCommand = parseResult.Bind&lt;RootCliCommand&gt;();</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// A root cli command which shows help if command is empty, i.e. no arguments or options are passed.
// Arguments and options should be optional, if they are required (no default values),
// then handler will not run and missing error message will be shown.

[CliCommand(Description = "A root cli command")]
public class RootHelpOnEmptyCliCommand
{
    [CliOption(Description = "Description for Option1")]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = "Description for Argument1")]
    public string Argument1 { get; set; } = "DefaultForArgument1";

    public void Run(CliContext context)
    {
        if (context.IsEmptyCommand())
            context.ShowHelp();
        else
            context.ShowValues();
    }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// Getting the value for a recursive option in a sub-command:

[CliCommand(Description = "A root cli command")]
public class RecursiveOptionCliCommand
{
    [CliOption(Recursive = true)]
    public bool RecursiveOption { get; set; }

    [CliCommand]
    public class SubCliCommand
    {
        [CliArgument]
        public string Argument1 { get; set; } = "DefaultForArgument1";

        public async Task RunAsync(CliContext context)
        {
            var parent = context.ParseResult.Bind&lt;RecursiveOptionCliCommand&gt;();

            await Console.Out.WriteLineAsync($"RecursiveOption = {parent.RecursiveOption}, Argument1 = {Argument1}");
        }
    }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// Sub-commands can get a reference to the parent command by adding a property of the parent command type.

[CliCommand(Description = "A root cli command with children that can access parent commands")]
public class ParentCommandAccessorCliCommand
{
    [CliOption(
        Description = "This is a global option (Recursive option on the root command), it can appear anywhere on the command line",
        Recursive = true)]
    public string GlobalOption1 { get; set; } = "DefaultForGlobalOption1";

    [CliArgument(Description = "Description for RootArgument1")]
    public string RootArgument1 { get; set; }

    public void Run(CliContext context)
    {
        context.ShowValues();
    }

    [CliCommand(Description = "A nested level 1 sub-command which accesses the root command")]
    public class Level1SubCliCommand
    {
        [CliOption(
            Description = "This is global for all sub commands (it can appear anywhere after the level-1 verb)",
            Recursive = true)]
        public string Level1RecursiveOption1 { get; set; } = "DefaultForLevel1RecursiveOption1";

        [CliArgument(Description = "Description for Argument1")]
        public string Argument1 { get; set; }

        // The parent command gets automatically injected
        public ParentCommandAccessorCliCommand RootCommand { get; set; }

        public void Run(CliContext context)
        {
            context.ShowValues();
        }

        [CliCommand(Description = "A nested level 2 sub-command which accesses its parent commands")]
        public class Level2SubCliCommand
        {
            [CliOption(Description = "Description for Option1")]
            public string Option1 { get; set; } = "DefaultForOption1";

            [CliArgument(Description = "Description for Argument1")]
            public string Argument1 { get; set; }

            // All ancestor commands gets injected
            public ParentCommandAccessorCliCommand RootCommand { get; set; }
            public Level1SubCliCommand ParentCommand { get; set; }

            public void Run(CliContext context)
            {
                context.ShowValues();

                Console.WriteLine();
                Console.WriteLine(@$"Level1RecursiveOption1 = {ParentCommand.Level1RecursiveOption1}");
                Console.WriteLine(@$"parent Argument1 = {ParentCommand.Argument1}");
                Console.WriteLine(@$"GlobalOption1 = {RootCommand.GlobalOption1}");
                Console.WriteLine(@$"RootArgument1 = {RootCommand.RootArgument1}");
            }
        }
    }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// Bundling of single-character options are supported, also known as stacking.
// Bundled options are single-character option aliases specified together after a single hyphen prefix.
// For example if you have options "-a", "-b" and "-c", you can bundle them like "-abc".
// Only the last option can specify an argument.
// Note that if you have an explicit option named "-abc" then it will win over bundled options.

[CliCommand]
public class OptionBundlingCliCommand
{
    [CliOption(Name = "-a")]
    public bool A { get; set; }

    [CliOption(Name = "-b")]
    public bool B { get; set; }

    [CliOption(Name = "-c")]
    public bool C { get; set; }

    public void Run(CliContext cliContext)
    {
        cliContext.ShowValues();
    }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">/*
    Apps that use System.CommandLine have built-in support for tab completion in certain shells. 
    To enable it, the end user has to [take a few steps once per shell](https://learn.microsoft.com/en-us/dotnet/standard/commandline/tab-completion#get-tab-completion-values-at-run-time). 
    Once the user does this, tab completion is automatic for static values in your app, such as enum values or values you 
    define by setting `CliOptionAttribute.AllowedValues` or `CliArgumentAttribute.AllowedValues`. 
    You can also customize the tab completion by getting values dynamically at runtime.

    In your command class, inherit `ICliGetCompletions` and implement `GetCompletions` method.
    This method will be called for every option and argument in your class.
    In the  method, you should switch according to the property name
    which corresponds to the option or argument whose completions will be retrieved.

    The dynamic tab completion list created by this code also appears in help output:
 */

[CliCommand(Description = "A root cli command with completions for options and arguments")]
public class GetCompletionsCliCommand : ICliGetCompletions
{
    [CliOption(Description = "Description for DateOption")]
    public DateTime DateOption { get; set; }

    [CliArgument(Description = "Description for FruitArgument")]
    public string FruitArgument { get; set; } = "DefaultForFruitArgument";

    public void Run(CliContext context)
    {
        if (context.IsEmptyCommand())
            context.ShowHelp();
        else
            context.ShowValues();
    }

    public IEnumerable&lt;CompletionItem&gt; GetCompletions(string propertyName, CompletionContext completionContext)
    {
        switch (propertyName)
        {
            case nameof(DateOption):
                var today = DateTime.Today;
                var dates = new List&lt;CompletionItem&gt;();

                foreach (var i in Enumerable.Range(1, 7))
                {
                    var date = today.AddDays(i);
                    dates.Add(new CompletionItem(
                        label: date.ToShortDateString(),
                        sortText: $"{i:2}"));
                }

                return dates;

            case nameof(FruitArgument):
                return new [] { "apple", "orange", "banana" }
                    .Select(value =&gt; new CompletionItem(value));
        }

        return Enumerable.Empty&lt;CompletionItem&gt;();
    }
}</code></pre></div></div></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Constructors</h2><div id="IDAEASection"><table id="ConstructorList" class="table is-hoverable"><tr><td><a href="M_DotMake_CommandLine_CliOptionAttribute__ctor.htm">CliOptionAttribute</a></td><td>Initializes a new instance of the <span class="selflink">CliOptionAttribute</span> class</td></tr></table></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Properties</h2><div id="IDBEASection"><table id="PropertyList" class="table is-hoverable"><tr><td><a href="P_DotMake_CommandLine_CliOptionAttribute_Alias.htm">Alias</a></td><td>
            Gets or sets the set of an alternative string that can be used on the command line to specify the option.
            When set, this will override the auto-generated short form alias.
            <p>If you want to set multiple aliases, you can use <a href="P_DotMake_CommandLine_CliOptionAttribute_Aliases.htm">Aliases</a>.</p><p>
            When manually setting a short form alias, if you don't specify a prefix, it will be prefixed automatically according to <a href="P_DotMake_CommandLine_CliCommandAttribute_ShortFormPrefixConvention.htm">ShortFormPrefixConvention</a>
            (e.g. <span class="code">-o</span> or <span class="code">--o</span> or <span class="code">/o</span>) unless it's set to <a href="T_DotMake_CommandLine_CliNamePrefixConvention.htm">None</a>.
            </p><p>The aliases will be also displayed in usage help of the command line application.</p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliOptionAttribute_Aliases.htm">Aliases</a></td><td>
            Gets or sets the set of alternative strings that can be used on the command line to specify the option.
            <p>If you want to set a single alias, you can use <a href="P_DotMake_CommandLine_CliOptionAttribute_Alias.htm">Alias</a>.</p><p>
            When manually setting an alias, if you don't specify a prefix, it will be prefixed automatically according to <a href="P_DotMake_CommandLine_CliCommandAttribute_NamePrefixConvention.htm">NamePrefixConvention</a>
            (e.g. <span class="code">--option</span>, <span class="code">-option</span> or <span class="code">/option</span>) unless it's set to <a href="T_DotMake_CommandLine_CliNamePrefixConvention.htm">None</a>.
            </p><p>The aliases will be also displayed in usage help of the command line application.</p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliOptionAttribute_AllowedValues.htm">AllowedValues</a></td><td>
            Gets or sets the list of allowed values for an option.
            <p>Configures an option to accept only the specified values, and to suggest them as command line completions.</p><p>Note that if the option's argument type is an enum, values are automatically added.</p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliOptionAttribute_AllowMultipleArgumentsPerToken.htm">AllowMultipleArgumentsPerToken</a></td><td>
            Gets or sets a value that indicates whether multiple argument tokens are allowed for each option identifier token.
            <p>
            If set to <span class="keyword"><span id="LST1BF101B1_0" data-languageSpecificText="vb=True|nu=true"></span></span>, the following command line is valid for passing multiple arguments:
            <div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">console</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-console">&gt; myapp --opt 1 2 3</code></pre></div></div>
            The following is equivalent and is always valid:
            <div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">console</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-console">&gt; myapp --opt 1 --opt 2 --opt 3</code></pre></div></div></p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliOptionAttribute_Arity.htm">Arity</a></td><td>
            Gets or sets the arity of the option's argument. The arity refers to the number of values that can be passed on the command line.
            <p>In most cases setting argument arity is not necessary as it is automatically determined based on the argument type (the decorated property's type):</p><ul><li>Boolean -&gt; ArgumentArity.ZeroOrOne</li><li>Collection types -&gt; ArgumentArity.ZeroOrMore</li><li>Everything else -&gt; ArgumentArity.ExactlyOne</li></ul></td></tr><tr><td><a href="P_DotMake_CommandLine_CliOptionAttribute_Description.htm">Description</a></td><td>
            Gets or sets the description of the option. This will be displayed in usage help of the command line application.
            </td></tr><tr><td><a href="P_DotMake_CommandLine_CliOptionAttribute_HelpName.htm">HelpName</a></td><td>
            Gets or sets the name of the option's argument when displayed in help.
            </td></tr><tr><td><a href="P_DotMake_CommandLine_CliOptionAttribute_Hidden.htm">Hidden</a></td><td>
            Gets or sets a value indicating whether the option is hidden.
            <p>
            You might want to support a command, option, or argument, but avoid making it easy to discover.
            For example, it might be a deprecated or administrative or preview feature.
            Use the <a href="P_DotMake_CommandLine_CliOptionAttribute_Hidden.htm">Hidden</a> property to prevent users from discovering such features by using tab completion or help.
            </p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliOptionAttribute_Name.htm">Name</a></td><td>
            Gets or sets the name of the option that will be used on the command line to specify the option.
            <p>
            When manually setting a name, if you don't specify a prefix, it will be prefixed automatically according to <a href="P_DotMake_CommandLine_CliCommandAttribute_NamePrefixConvention.htm">NamePrefixConvention</a>
            (e.g. <span class="code">--option</span>, <span class="code">-option</span> or <span class="code">/option</span>) unless it's set to <a href="T_DotMake_CommandLine_CliNamePrefixConvention.htm">None</a>.
            </p><p>
            If not set (or is empty/whitespace), the name of the property that this attribute is applied to, will be used to generate option name automatically:
            These suffixes will be stripped from the property name: <span class="code">RootCliCommandOption, RootCommandOption, SubCliCommandOption, SubCommandOption, CliCommandOption, CommandOption, CliOption, Option</span>.
            Then the name will be converted to kebab-case and will be prefixed with POSIX convention two hyphens (<span class="code">--</span>), for example:
            <ul><li>If property name is <span class="code">Input</span> or <span class="code">InputOption</span> or <span class="code">InputCliOption</span> -&gt; option name will be <span class="code">--input</span></li><li>If property name is <span class="code">SearchPath</span> or <span class="code">SearchPathOption</span> or <span class="code">SearchPathCliOption</span> -&gt; option name will be <span class="code">--search-path</span></li></ul></p><p>Default conventions can be changed via parent command's <a href="P_DotMake_CommandLine_CliCommandAttribute_NameCasingConvention.htm">NameCasingConvention</a> and <a href="P_DotMake_CommandLine_CliCommandAttribute_NamePrefixConvention.htm">NamePrefixConvention</a> properties.</p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliOptionAttribute_Recursive.htm">Recursive</a></td><td>
            Gets or sets a value indicating whether the option is added to its immediate parent command or commands and recursively to their subcommands.
            <p>For example, <span class="code">--help</span> is a recursive option.</p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliOptionAttribute_Required.htm">Required</a></td><td>
            Gets or sets a value indicating whether the option is required when its parent command is invoked.
            Default is auto-detected.
            <p>
            An option/argument will be considered required when
            <ul><li>
                    There is no property initializer and the property type is a reference type (e.g. <span class="code">public string Arg { get; set; }</span>). 
                    <span class="code">string</span> is a reference type which has a null as the default value but <span class="code">bool</span> and <span class="code">enum</span> are value
                    types which already have non-null default values. <span class="code">Nullable&lt;T&gt;</span> is a reference type, e.g. <span class="code">bool?</span>.
                </li><li>
                    There is a property initializer, but it's initialized with <span class="code">null</span> or <span class="code">null!</span> (SuppressNullableWarningExpression)
                    (e.g. <span class="code">public string Arg { get; set; } = null!;</span>).
                </li><li>If it's forced via attribute property <span class="code">Required</span> (e.g. <span class="code">[CliArgument(Required = true)]</span>).</li><li>
                    If it's forced via <span class="code">required</span> modifier (e.g. <span class="code">public required string Opt { get; set; }</span>).
                    Note that for being able to use <span class="code">required</span> modifier, if your target framework is below net7.0, 
                    you also need <span class="code">11.0</span> tag (minimum) in your .csproj file (our source generator supplies the polyfills
                    automatically as long as you set C# language version to 11).
                </li></ul></p><p>
            An option/argument will be considered optional when
            <ul><li>
                    There is no property initializer (e.g. <span class="code">public bool Opt { get; set; }</span>) but the property type is a value type 
                    which already have non-null default value.
                </li><li>
                    There is a property initializer, and it's not initialized with <span class="code">null</span> or <span class="code">null!</span> (SuppressNullableWarningExpression)
                    (e.g. <span class="code">public string Arg { get; set; } = "Default";</span>).
                </li><li>If it's forced via attribute property <span class="code">Required</span> (e.g. <span class="code">[CliArgument(Required = false)]</span>).</li></ul></p><p>
            When an option is required, the option has to be specified on the command line and if its parent command is invoked
            without it, an error message is displayed and the command handler isn't called.
            When an option is not required, the option doesn't have to be specified on the command line, the default value provides the option value.
            </p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliOptionAttribute_ValidationMessage.htm">ValidationMessage</a></td><td>Gets or sets an error message to show when <a href="P_DotMake_CommandLine_CliOptionAttribute_ValidationPattern.htm">ValidationPattern</a> does not match and validation fails.</td></tr><tr><td><a href="P_DotMake_CommandLine_CliOptionAttribute_ValidationPattern.htm">ValidationPattern</a></td><td>
            Gets or sets a regular expression pattern used to determine if option's argument value(s) is valid.
            <p>
            Note that you can specify regular expression options inline in the pattern with the syntax <span class="code">(?imnsx-imnsx)</span>:
            <div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">ValidationPattern = @"(?i)^[a-z]+$"</code></pre></div></div><a href="https://learn.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference" target="_blank" rel="noopener noreferrer">Regular expression quick reference</a><br /><a href="https://learn.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-options" target="_blank" rel="noopener noreferrer">Regular expression options</a></p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliOptionAttribute_ValidationRules.htm">ValidationRules</a></td><td>
            Gets or sets a set of validation rules used to determine if option's argument value(s) is valid.
            <p>
            When combining validation rules, use bitwise 'or' operator(| in C#):
            <div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">ValidationRules = CliValidationRules.NonExistingFile | CliValidationRules.LegalPath</code></pre></div></div></p></td></tr></table></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>See Also</h2><div id="seeAlsoSection"><h4>Reference</h4><div><a href="N_DotMake_CommandLine.htm">DotMake.CommandLine Namespace</a></div></div></div><div id="InThisArticleColumn" class="column is-hidden-mobile"><nav class="menu sticky is-hidden"><p class="menu-label"><strong>In This Article</strong></p><ul id="InThisArticleMenu" class="menu-list"><li><a class="quickLink">Definition</a></li><li><a class="quickLink">Example</a></li><li><a class="quickLink">Constructors</a></li><li><a class="quickLink">Properties</a></li><li><a class="quickLink">See Also</a></li></ul></nav></div></div></div><footer id="PageFooter" class="footer border-top py-3 fixedFooter"><div class="columns"><div id="FooterContent" class="column"><p>Copyright © 2023-2025 DotMake</p> 
				</div></div></footer></div><script>$(function(){
SetDefaultLanguage("cs");
LoadTocFile(null, null);
InitializeQuickLinks();

$(".toggleSection" ).click(function () {
    SectionExpandCollapse(this);
});

$(".toggleSection").keypress(function () {
    SectionExpandCollapseCheckKey(this, event)
});
hljs.highlightAll();
});</script></body></html>