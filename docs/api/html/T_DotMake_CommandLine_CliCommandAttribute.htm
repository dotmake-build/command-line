<!DOCTYPE html []><html lang="en-US"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="shortcut icon" href="../icons/favicon.ico" /><link rel="stylesheet" href="../css/bulma.css" /><link rel="stylesheet" href="../css/font-awesome.min.css" /><link rel="stylesheet" href="../css/presentationStyle.css" /><link rel="stylesheet" href="../css/vs.min.css" /><script src="../scripts/jquery-3.5.1.min.js"></script><script src="../scripts/clipboard.min.js"></script><script src="../scripts/highlight.min.js"></script><script src="../scripts/presentationStyle.js"></script><title>CliCommandAttribute Class</title><meta name="Title" content="CliCommandAttribute" /><meta name="Help.Id" content="T:DotMake.CommandLine.CliCommandAttribute" /><meta name="Help.ContentType" content="Reference" /><meta name="container" content="DotMake.CommandLine" /><meta name="guid" content="T_DotMake_CommandLine_CliCommandAttribute" /><meta name="Description" content="Specifies a class that represents a command which is a specific action that the command line application performs." /><meta name="tocFile" content="../toc/IDAA.xml" /></head><body><div class="fixedLayout"><div id="Header" class="fixedHeader"><div class="pageHeader level mb-0 py-2 px-4"><div id="TitleContainer" class="level-left"><div class="level-item"><img style="height: 64px;" src="../icons/logo128.png" /></div><div id="DocumentationTitle" class="level-item">DotMake Command-Line Documentation</div></div><div id="LangFilterSearchContainer" class="level-right"><div class="level-item"><div class="dropdown is-hoverable"><div class="dropdown-trigger"><button class="button" aria-haspopup="true" aria-controls="dropdown-menu"><span id="CurrentLanguage"></span><span class="icon is-small"><i class="fa fa-angle-down" aria-hidden="true"></i></span></button></div><div class="dropdown-menu" role="menu"><div id="LanguageSelections" class="dropdown-content"><a class="dropdown-item languageFilterItem" data-languageId="cs">C#</a></div></div></div></div><div class="level-item"><form id="SearchForm" action="#" onsubmit="TransferToSearchPage(); return false;"><div class="field"><div class="control has-icons-left"><input id="SearchTerms" class="input" type="text" maxlength="200" placeholder="Search" /><span class="icon is-small is-left"><i class="fa fa-search"></i></span><button id="SearchButton" type="submit" class="is-hidden"></button></div></div></form></div></div></div></div><div class="fixedContent"><nav class="breadcrumb my-1 px-2 border-bottom" role="navigation"><ul id="TopicBreadcrumbs" /></nav><div id="ContentContainer" class="columns pl-5 pr-5 fixedContent"><div id="ShowHideTOCColumn" class="column is-hidden-tablet"><a id="ShowHideTOC">Show/Hide TOC</a></div><div id="TOCColumn" class="column is-hidden-mobile"><nav class="toc"><ul id="TableOfContents" class="toc-menu" /></nav></div><div id="Resizer" class="is-hidden"></div><div id="TopicContent" class="column content is-7"><h1>Cli<wbr />Command<wbr />Attribute Class</h1><div class="summary">
            Specifies a class that represents a command which is a specific action that the command line application performs.
            <div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">[CliCommand]
public class SomeCliCommand</code></pre></div></div>
            The class that this attribute is applied to, 
            <ul><li>will be a root command if the class is not a nested class and other's <a href="P_DotMake_CommandLine_CliCommandAttribute_Children.htm">Children</a> property and self's <a href="P_DotMake_CommandLine_CliCommandAttribute_Parent.htm">Parent</a> property is not set.</li><li>will be a sub command if the class is a nested class or other's <a href="P_DotMake_CommandLine_CliCommandAttribute_Children.htm">Children</a> property or self's <a href="P_DotMake_CommandLine_CliCommandAttribute_Parent.htm">Parent</a> property is set.</li></ul><p><b>Commands:</b> A command in command-line input is a token that specifies an action or defines a group of related actions. For example:
            <ul><li>In <span class="code">dotnet run</span>, <span class="code">run</span> is a command that specifies an action.</li><li>In <span class="code">dotnet tool install</span>, <span class="code">install</span> is a command that specifies an action, and <span class="code">tool</span> is a command that specifies a <br />
                    group of related commands. There are other tool-related commands, such as <span class="code">tool uninstall</span>, <span class="code">tool list</span>,<br />
                    and <span class="code">tool update</span>.</li></ul></p><p><b>Root commands:</b> The root command is the one that specifies the name of the app's executable. For example, the <span class="code">dotnet</span> command specifies the <span class="code">dotnet.exe</span> executable.
            </p><p><b>Subcommands:</b> Most command-line apps support subcommands, also known as verbs. For example, the <span class="code">dotnet</span> command has a <span class="code">run</span> subcommand that you invoke by entering <span class="code">dotnet run</span>.
            Subcommands can have their own subcommands. In <span class="code">dotnet tool install</span>, <span class="code">install</span> is a <span class="code">subcommand</span> of tool.
            </p><p><b>Inheritance:</b> When you have repeating/common options and arguments for your commands, you can define them once in a base class and then 
            share them by inheriting that base class in other command classes.Interfaces are also supported !
            </p><p><b>Handler:</b> Add a method with name Run or RunAsync to make it the handler for the CLI command. The method can have one of the following signatures:
            <ul><li><span class="code">void Run()</span></li><li><span class="code">int Run()</span></li><li><span class="code">async Task RunAsync()</span></li><li><span class="code">async Task&lt;int&gt; RunAsync()</span></li></ul>
            Optionally the method signature can have a <a href="T_DotMake_CommandLine_CliContext.htm">CliContext</a> parameter in case you need to access it:
            <ul><li><span class="code">Run(CliContext context)</span></li><li><span class="code">RunAsync(CliContext context)</span></li></ul></p><p>
            We also provide interfaces <a href="T_DotMake_CommandLine_ICliRun.htm">ICliRun</a>, <a href="T_DotMake_CommandLine_ICliRunWithReturn.htm">ICliRunWithReturn</a>, <a href="T_DotMake_CommandLine_ICliRunWithContext.htm">ICliRunWithContext</a>, <a href="T_DotMake_CommandLine_ICliRunWithContextAndReturn.htm">ICliRunWithContextAndReturn</a>
            and async versions <a href="T_DotMake_CommandLine_ICliRunAsync.htm">ICliRunAsync</a>, <a href="T_DotMake_CommandLine_ICliRunAsyncWithReturn.htm">ICliRunAsyncWithReturn</a>, <a href="T_DotMake_CommandLine_ICliRunAsyncWithContext.htm">ICliRunAsyncWithContext</a>, <a href="T_DotMake_CommandLine_ICliRunAsyncWithContextAndReturn.htm">ICliRunAsyncWithContextAndReturn</a> 
            that you can inherit in your command class.
            Normally you don't need an interface for a handler method as the source generator can detect it automatically,
            but the interfaces can be used to prevent your IDE complain about unused method in class.
            </p><p>
            The signatures which return int value, sets the ExitCode of the app.
            If no handler method is provided, then by default it will show help for the command.
            This can be also controlled manually by extension method <a href="M_DotMake_CommandLine_CliContext_ShowHelp.htm">ShowHelp<span id="LSTA4FAE012_0" data-languageSpecificText="cs=()|vb=|cpp=()|nu=()|fs=()"></span></a>.
            Other extension methods <a href="M_DotMake_CommandLine_CliContext_IsEmptyCommand.htm">IsEmptyCommand<span id="LSTA4FAE012_1" data-languageSpecificText="cs=()|vb=|cpp=()|nu=()|fs=()"></span></a>, <a href="M_DotMake_CommandLine_CliContext_ShowValues.htm">ShowValues<span id="LSTA4FAE012_2" data-languageSpecificText="cs=()|vb=|cpp=()|nu=()|fs=()"></span></a> and <a href="M_DotMake_CommandLine_CliContext_ShowHierarchy.htm">ShowHierarchy(Boolean)</a> are also useful.
             </p></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Definition</h2><div id="IDBSection"><strong>Namespace:</strong> <a href="N_DotMake_CommandLine.htm">DotMake.CommandLine</a><br /><strong>Assembly:</strong> DotMake.CommandLine (in DotMake.CommandLine.dll) Version: 2.6.2<div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><span class="buttons"><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></span></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs"><span class="keyword">public</span> <span class="keyword">class</span> <span class="identifier">CliCommandAttribute</span> : <span class="identifier">Attribute</span></code></pre></div></div><dl class="inheritanceHierarchy"><dt>Inheritance</dt><dd><a href="https://learn.microsoft.com/dotnet/api/system.object" target="_blank" rel="noopener noreferrer">Object</a>  <span class="icon is-small"><i class="fa fa-arrow-right"></i></span>  <a href="https://learn.microsoft.com/dotnet/api/system.attribute" target="_blank" rel="noopener noreferrer">Attribute</a>  <span class="icon is-small"><i class="fa fa-arrow-right"></i></span>  <span class="selflink">CliCommandAttribute</span></dd></dl></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Example</h2><div id="IDBCSection"><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// Class-based model
// Create a simple class like this:

[CliCommand(Description = "A root cli command")]
public class RootCliCommand
{
    [CliOption(Description = "Description for Option1")]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = "Description for Argument1")]
    public string Argument1 { get; set; }

    public void Run()
    {
        Console.WriteLine($@"Handler for '{GetType().FullName}' is run:");
        Console.WriteLine($@"Value for {nameof(Option1)} property is '{Option1}'");
        Console.WriteLine($@"Value for {nameof(Argument1)} property is '{Argument1}'");
        Console.WriteLine();
    }
}

        //In Program.cs, add this single line:
        Cli.Run&lt;RootCliCommand&gt;(args);

        //If you need to simply parse the command-line arguments without invocation, use this:
        var result = Cli.Parse&lt;RootCliCommand&gt;(args);
        var rootCliCommand = result.Bind&lt;RootCliCommand&gt;();</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// A root cli command which shows help if command is empty, i.e. no arguments or options are passed.
// Arguments and options should be optional, if they are required (no default values),
// then handler will not run and missing error message will be shown.

[CliCommand(Description = "A root cli command")]
public class RootHelpOnEmptyCliCommand
{
    [CliOption(Description = "Description for Option1")]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = "Description for Argument1")]
    public string Argument1 { get; set; } = "DefaultForArgument1";

    public void Run(CliContext context)
    {
        if (context.IsEmptyCommand())
            context.ShowHelp();
        else
            context.ShowValues();
    }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">/*
  We also provide interfaces `ICliRun`, `ICliRunWithReturn`, `ICliRunWithContext`, `ICliRunWithContextAndReturn`
  and async versions `ICliRunAsync`, `ICliRunAsyncWithReturn`, `ICliRunAsyncWithContext`, `ICliRunAsyncWithContextAndReturn` 
  that you can inherit in your command class.
  Normally you don't need an interface for a handler method as the source generator can detect it automatically,
  but the interfaces can be used to prevent your IDE complain about unused method in class.
*/

[CliCommand(Description = "A root cli command with async handler with Task (return void)")]
public class RunAsyncCliCommand : ICliRunAsync
{
    [CliOption(Description = "Description for Option1")]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = "Description for Argument1")]
    public string Argument1 { get; set; }

    public async Task RunAsync()
    {
        Console.WriteLine($@"Handler for '{GetType().FullName}' is run:");
        Console.WriteLine($@"Value for {nameof(Option1)} property is '{Option1}'");
        Console.WriteLine($@"Value for {nameof(Argument1)} property is '{Argument1}'");
        Console.WriteLine();

        await Task.Delay(1000);
    }
}

[CliCommand(Description = "A root cli command with async handler with Task&lt;int&gt; (return int)")]
public class RunAsyncWithReturnCliCommand : ICliRunAsyncWithReturn
{
    [CliOption(Description = "Description for Option1")]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = "Description for Argument1")]
    public string Argument1 { get; set; }

    public async Task&lt;int&gt; RunAsync()
    {
        Console.WriteLine($@"Handler for '{GetType().FullName}' is run:");
        Console.WriteLine($@"Value for {nameof(Option1)} property is '{Option1}'");
        Console.WriteLine($@"Value for {nameof(Argument1)} property is '{Argument1}'");
        Console.WriteLine();

        await Task.Delay(1000);
        return 0;
    }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// Note that you can have a specific type (other than `string`) for a property which a `CliOption` or `CliArgument`
// attribute is applied to, for example these properties will be parsed and bound/populated automatically:

[CliCommand]
public class WriteFileCliCommand
{
    [CliArgument]
    public FileInfo OutputFile { get; set; }

    [CliOption]
    public List&lt;string&gt; Lines { get; set; }

    public void Run()
    {
        if (OutputFile.Exists)
            return;

        using (var streamWriter = OutputFile.CreateText())
        {
            foreach (var line in Lines)
            {
                streamWriter.WriteLine(line);
            }
        }
    }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// Any type with a public constructor or a static `Parse` method with a string parameter (other parameters, if any,
// should be optional) - These types can be bound/parsed automatically even if they are wrapped
// with `Enumerable` or `Nullable` type.

[CliCommand]
public class ArgumentConverterCliCommand
{
    [CliOption(Required = false)]
    public ClassWithConstructor Opt { get; set; }

    [CliOption(Required = false, AllowMultipleArgumentsPerToken = true)]
    public ClassWithConstructor[] OptArray { get; set; }

    [CliOption(Required = false)]
    public CustomStruct? OptNullable { get; set; }

    [CliOption(Required = false)]
    public IEnumerable&lt;ClassWithConstructor&gt; OptEnumerable { get; set; }

    [CliOption(Required = false)]
    public List&lt;ClassWithConstructor&gt; OptList { get; set; }

    [CliOption(Required = false)]
    public CustomList&lt;ClassWithConstructor&gt; OptCustomList { get; set; }

    [CliArgument]
    public IEnumerable&lt;ClassWithParser&gt; Arg { get; set; }

    public void Run(CliContext context)
    {
        context.ShowValues();
    }
}

public class ClassWithConstructor
{
    private readonly string value;

    public ClassWithConstructor(string value)
    {
        if (value == "exception")
            throw new Exception("Exception in ClassWithConstructor");

        this.value = value;
    }

    public override string ToString()
    {
        return value;
    }
}

public class ClassWithParser
{
    private string value;

    public override string ToString()
    {
        return value;
    }

    public static ClassWithParser Parse(string value)
    {
        if (value == "exception")
            throw new Exception("Exception in ClassWithParser");

        var instance = new ClassWithParser();
        instance.value = value;
        return instance;
    }
}

public struct CustomStruct
{
    private readonly string value;

    public CustomStruct(string value)
    {
        this.value = value;
    }

    public override string ToString()
    {
        return value;
    }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// Arrays, lists, collections - any type that implements `IEnumerable&lt;T&gt;` and has a public constructor with a `IEnumerable&lt;T&gt;`
// or `IList&lt;T&gt;` parameter (other parameters, if any, should be optional).
// If type is generic `IEnumerable&lt;T&gt;`, `IList&lt;T&gt;`, `ICollection&lt;T&gt;` interfaces itself, array `T[]` will be used.
// If type is non-generic `IEnumerable`, `IList`, `ICollection` interfaces itself, array `string[]` will be used.

[CliCommand]
public class EnumerableCliCommand
{
    [CliOption(Required = false)]
    public IEnumerable&lt;int&gt; OptEnumerable { get; set; }

    [CliOption(Required = false)]
    public List&lt;string&gt; OptList { get; set; }

    [CliOption(Required = false, AllowMultipleArgumentsPerToken = true)]
    public FileAccess[] OptEnumArray { get; set; }

    [CliOption(Required = false)]
    public Collection&lt;int?&gt; OptCollection { get; set; }

    [CliOption(Required = false)]
    public HashSet&lt;string&gt; OptHashSet { get; set; }

    [CliOption(Required = false)]
    public Queue&lt;FileInfo&gt; OptQueue { get; set; }

    [CliOption(Required = false)]
    public CustomList&lt;string&gt; OptCustomList { get; set; }

    [CliArgument]
    public IList ArgIList { get; set; }

    public void Run(CliContext context)
    {
        context.ShowValues();
    }
}

public class CustomList&lt;T&gt; : List&lt;T&gt;
{
    public CustomList(IEnumerable&lt;T&gt; items)
        : base(items)
    {
        if (items is IEnumerable&lt;string&gt; strings &amp;&amp; strings.First() == "exception")
            throw new Exception("Exception in CustomList");
    }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// For example, change the name casing and prefix convention:

[CliCommand(
    Description = "A cli command with snake_case name casing and forward slash prefix conventions",
    NameCasingConvention = CliNameCasingConvention.SnakeCase,
    NamePrefixConvention = CliNamePrefixConvention.ForwardSlash,
    ShortFormPrefixConvention = CliNamePrefixConvention.ForwardSlash
)]
public class RootSnakeSlashCliCommand
{
    [CliOption(Description = "Description for Option1")]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = "Description for Argument1")]
    public string Argument1 { get; set; }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">/*
    Defining sub-commands in DotMake.Commandline is very easy. We simply use nested classes to create a hierarchy.
    Just make sure you apply `CliCommand` attribute to the nested classes as well.
    Command hierarchy in below example is:

     TestApp
     └╴level-1
       └╴level-2
*/

[CliCommand(Description = "A root cli command with nested children")]
public class RootWithNestedChildrenCliCommand
{
    [CliOption(Description = "Description for Option1")]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = "Description for Argument1")]
    public string Argument1 { get; set; } = "DefaultForArgument1";

    public void Run(CliContext context)
    {
        if (context.IsEmptyCommand())
            context.ShowHierarchy();
        else
            context.ShowValues();
    }

    [CliCommand(Description = "A nested level 1 sub-command")]
    public class Level1SubCliCommand
    {
        [CliOption(Description = "Description for Option1")]
        public string Option1 { get; set; } = "DefaultForOption1";

        [CliArgument(Description = "Description for Argument1")]
        public string Argument1 { get; set; }

        public void Run(CliContext context)
        {
            context.ShowValues();
        }

        [CliCommand(Description = "A nested level 2 sub-command")]
        public class Level2SubCliCommand
        {
            [CliOption(Description = "Description for Option1")]
            public string Option1 { get; set; } = "DefaultForOption1";

            [CliArgument(Description = "Description for Argument1")]
            public string Argument1 { get; set; }

            public void Run(CliContext context)
            {
                context.ShowValues();
            }
        }
    }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">/*
    Another way to create hierarchy between commands, especially if you want to use standalone classes,
    is to use `Children` property of `CliCommand` attribute to specify array of `typeof` child classes.
    Command hierarchy in below example is:

     TestApp
     └╴external-level-1
       └╴external-level-2
*/

[CliCommand(
    Description = "A root cli command with external children",
    Children = new []
    {
        typeof(ExternalLevel1SubCliCommand),
    }
)]
public class RootWithExternalChildrenCliCommand
{
    [CliOption(Description = "Description for Option1")]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = "Description for Argument1")]
    public string Argument1 { get; set; } = "DefaultForArgument1";

    public void Run(CliContext context)
    {
        if (context.IsEmptyCommand())
            context.ShowHierarchy();
        else
            context.ShowValues();
    }
}

[CliCommand(
    Description = "An external level 1 sub-command",
    Children = new[]
    {
        typeof(ExternalLevel2SubCliCommand),
    }
)]
public class ExternalLevel1SubCliCommand
{
    [CliOption(Description = "Description for Option1")]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = "Description for Argument1")]
    public string Argument1 { get; set; }

    public void Run(CliContext context)
    {
        context.ShowValues();
    }
}

[CliCommand(Description = "An external level 2 sub-command")]
public class ExternalLevel2SubCliCommand
{
    [CliOption(Description = "Description for Option1")]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = "Description for Argument1")]
    public string Argument1 { get; set; }

    public void Run(CliContext context)
    {
        context.ShowValues();
    }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">/*
    Another way to create hierarchy between commands, especially if you want to use standalone classes,
    is to use `Parent` property of `CliCommand` attribute to specify `typeof` parent class.
    Command hierarchy in below example is:

     TestApp
     └╴external-level-1-with-parent
       └╴external-level-2-with-parent
*/

[CliCommand(
    Description = "A root cli command with external children"
)]
public class RootAsExternalParentCliCommand
{
    [CliOption(Description = "Description for Option1")]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = "Description for Argument1")]
    public string Argument1 { get; set; } = "DefaultForArgument1";

    public void Run(CliContext context)
    {
        if (context.IsEmptyCommand())
            context.ShowHierarchy();
        else
            context.ShowValues();
    }
}

[CliCommand(
    Description = "An external level 1 sub-command",
    Parent = typeof(RootAsExternalParentCliCommand)
)]
public class ExternalLevel1WithParentSubCliCommand
{
    [CliOption(Description = "Description for Option1")]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = "Description for Argument1")]
    public string Argument1 { get; set; }

    public void Run(CliContext context)
    {
        context.ShowValues();
    }
}

[CliCommand(
    Description = "An external level 2 sub-command",
    Parent = typeof(ExternalLevel1WithParentSubCliCommand)
)]
public class ExternalLevel2WithParentSubCliCommand
{
    [CliOption(Description = "Description for Option1")]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = "Description for Argument1")]
    public string Argument1 { get; set; }

    public void Run(CliContext context)
    {
        context.ShowValues();
    }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// When you have repeating/common options and arguments for your commands, you can define them once in a base class and then 
// share them by inheriting that base class in other command classes.Interfaces are also supported !

// The property attribute and the property initializer from the most derived class in the hierarchy will be used 
// (they will override the base ones). The command handler (Run or RunAsync) will be also inherited.
// So in the above example, `InheritanceCliCommand` inherits options `Username`, `Password` from a base class and
// option `Department` from an interface. Note that the property initializer for `Department` is in the derived class, 
// so that default value will be used.

[CliCommand]
public class InheritanceCliCommand : CredentialCommandBase, IDepartmentCommand
{
    public string Department { get; set; } = "Accounting";
}

public abstract class CredentialCommandBase
{
    [CliOption(Description = "Username of the identity performing the command")]
    public string Username { get; set; } = "admin";

    [CliOption(Description = "Password of the identity performing the command")]
    public string Password { get; set; }

    public void Run()
    {
        Console.WriteLine($@"I am {Username}");
    }
}

public interface IDepartmentCommand
{
    [CliArgument(Description = "Department of the identity performing the command (interface)")]
    string Department { get; set; }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// Localizing commands, options and arguments is supported.
// You can specify a `nameof` operator expression with a resource property (generated by resx) in the attribute's argument (for `string` types only)
// and the source generator will smartly use the resource property accessor as the value of the argument so that it can localize at runtime.
// If the property in the `nameof` operator expression does not point to a resource property, then the name of that property will be used as usual.
// The reason we use `nameof` operator is that attributes in `.NET` only accept compile-time constants and you get `CS0182` error if not,
// so specifying resource property directly is not possible as it's not a compile-time constant but it's a static property access.

[CliCommand(Description = nameof(TestResources.CommandDescription))]
internal class LocalizedCliCommand
{
    [CliOption(Description = nameof(TestResources.OptionDescription))]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = nameof(TestResources.ArgumentDescription))]
    public string Argument1 { get; set; }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// If a command represents a group and not an action, you may want to show help.
// If `Run` or `RunAsync` method is missing in a command class, then by default it will show help.
// You can also manually trigger help in `Run` or `RunAsync` method of a command class via calling `CliContext.ShowHelp`.
// For testing a command, other methods `CliContext.ShowValues` and `CliContext.IsEmptyCommand` are also useful.
// `ShowValues` shows parsed values for current command and its arguments and options.

// See below example; root command does not have a handler method so it will always show help
// and sub-command will show help if command is specified without any arguments or option,
// and it will show(dump) values if not:

[CliCommand(Description = "A root cli command")]
public class HelpCliCommand
{
    [CliOption(Description = "Description for Option1")]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = "Description for Argument1")]
    public string Argument1 { get; set; } = "DefaultForArgument1";

    [CliCommand(Description = "A sub cli command")]
    public class SubCliCommand
    {
        [CliArgument(Description = "Description for Argument2")]
        public string Argument2 { get; set; } = "DefaultForArgument2";

        public void Run(CliContext context)
        {
            if (context.IsEmptyCommand())
                context.ShowHelp();
            else
                context.ShowValues();
        }
    }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// In `[CliOption]` and `[CliArgument]` attributes;
// `ValidationRules` property allows setting predefined validation rules such as `ExistingFile`, `NonExistingFile`, `ExistingDirectory`,
// `NonExistingDirectory`, `ExistingFileOrDirectory`, `NonExistingFileOrDirectory`, `LegalPath`, `LegalFileName`, `LegalUri`, `LegalUrl`.
// Validation rules can be combined.
// `ValidationPattern` property allows setting a regular expression pattern for custom validation,
// and `ValidationMessage` property allows setting a custom error message to show when `ValidationPattern` does not match.

[CliCommand]
public class ValidationCliCommand
{
    [CliOption(Required = false, ValidationRules = CliValidationRules.ExistingFile)]
    public FileInfo OptFile1 { get; set; }

    [CliOption(Required = false, ValidationRules = CliValidationRules.NonExistingFile | CliValidationRules.LegalPath)]
    public string OptFile2 { get; set; }

    [CliOption(Required = false, ValidationRules = CliValidationRules.ExistingDirectory)]
    public DirectoryInfo OptDir { get; set; }

    [CliOption(Required = false, ValidationPattern = @"(?i)^[a-z]+$")]
    public string OptPattern1 { get; set; }

    [CliOption(Required = false, ValidationPattern = @"(?i)^[a-z]+$", ValidationMessage = "Custom error message")]
    public string OptPattern2 { get; set; }

    [CliOption(Required = false, ValidationRules = CliValidationRules.LegalUrl)]
    public string OptUrl { get; set; }

    [CliOption(Required = false, ValidationRules = CliValidationRules.LegalUri)]
    public string OptUri { get; set; }

    [CliArgument(Required = false, ValidationRules = CliValidationRules.LegalFileName)]
    public string OptFileName { get; set; }

    public void Run(CliContext context)
    {
        context.ShowValues();
    }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">/*
    Apps that use System.CommandLine have built-in support for tab completion in certain shells. 
    To enable it, the end user has to [take a few steps once per shell](https://learn.microsoft.com/en-us/dotnet/standard/commandline/tab-completion#get-tab-completion-values-at-run-time). 
    Once the user does this, tab completion is automatic for static values in your app, such as enum values or values you 
    define by setting `CliOptionAttribute.AllowedValues` or `CliArgumentAttribute.AllowedValues`. 
    You can also customize the tab completion by getting values dynamically at runtime.

    In your command class, inherit `ICliGetCompletions` and implement `GetCompletions` method.
    This method will be called for every option and argument in your class.
    In the  method, you should switch according to the property name
    which corresponds to the option or argument whose completions will be retrieved.

    The dynamic tab completion list created by this code also appears in help output:
 */

[CliCommand(Description = "A root cli command with completions for options and arguments")]
public class GetCompletionsCliCommand : ICliGetCompletions
{
    [CliOption(Description = "Description for DateOption")]
    public DateTime DateOption { get; set; }

    [CliArgument(Description = "Description for FruitArgument")]
    public string FruitArgument { get; set; } = "DefaultForFruitArgument";

    public void Run(CliContext context)
    {
        if (context.IsEmptyCommand())
            context.ShowHelp();
        else
            context.ShowValues();
    }

    public IEnumerable&lt;CompletionItem&gt; GetCompletions(string propertyName, CompletionContext completionContext)
    {
        switch (propertyName)
        {
            case nameof(DateOption):
                var today = DateTime.Today;
                var dates = new List&lt;CompletionItem&gt;();

                foreach (var i in Enumerable.Range(1, 7))
                {
                    var date = today.AddDays(i);
                    dates.Add(new CompletionItem(
                        label: date.ToShortDateString(),
                        sortText: $"{i:2}"));
                }

                return dates;

            case nameof(FruitArgument):
                return new [] { "apple", "orange", "banana" }
                    .Select(value =&gt; new CompletionItem(value));
        }

        return Enumerable.Empty&lt;CompletionItem&gt;();
    }
}</code></pre></div></div></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Constructors</h2><div id="IDAEASection"><table id="ConstructorList" class="table is-hoverable"><tr><td><a href="M_DotMake_CommandLine_CliCommandAttribute__ctor.htm">CliCommandAttribute</a></td><td>Initializes a new instance of the <span class="selflink">CliCommandAttribute</span> class</td></tr></table></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Properties</h2><div id="IDBEASection"><table id="PropertyList" class="table is-hoverable"><tr><td><a href="P_DotMake_CommandLine_CliCommandAttribute_Alias.htm">Alias</a></td><td>
            Gets or sets the set of an alternative string that can be used on the command line to specify the command.
            When set, this will override the auto-generated short form alias.
            <p>If you want to set multiple aliases, you can use <a href="P_DotMake_CommandLine_CliCommandAttribute_Aliases.htm">Aliases</a>.</p><p>The aliases will be also displayed in usage help of the command line application.</p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliCommandAttribute_Aliases.htm">Aliases</a></td><td>
            Gets or sets the set of alternative strings that can be used on the command line to specify the command.
            <p>If you want to set a single alias, you can use <a href="P_DotMake_CommandLine_CliCommandAttribute_Alias.htm">Alias</a>.</p><p>The aliases will be also displayed in usage help of the command line application.</p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliCommandAttribute_Children.htm">Children</a></td><td>
            Gets or sets the children of the command. This property is used when you prefer to use a non-nested classes for subcommands,
            i.e. when you want to separate root command and subcommands into different classes/files.
            If a class in the list, is already a nested class, then that class will be ignored.
            </td></tr><tr><td><a href="P_DotMake_CommandLine_CliCommandAttribute_Description.htm">Description</a></td><td>
            Gets or sets the description of the command. This will be displayed in usage help of the command line application.
            </td></tr><tr><td><a href="P_DotMake_CommandLine_CliCommandAttribute_Hidden.htm">Hidden</a></td><td>
            Gets or sets a value indicating whether the command is hidden.
            <p>
            You might want to support a command, option, or argument, but avoid making it easy to discover.
            For example, it might be a deprecated or administrative or preview feature.
            Use the <a href="P_DotMake_CommandLine_CliCommandAttribute_Hidden.htm">Hidden</a> property to prevent users from discovering such features by using tab completion or help.
            </p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliCommandAttribute_Name.htm">Name</a></td><td>
            Gets or sets the name of the command that will be used on the command line to specify the command.
            This will be displayed in usage help of the command line application.
            <p>
            If not set (or is empty/whitespace), the name of the class that this attribute is applied to, will be used to generate command name automatically:
            These suffixes will be stripped from the class name: <span class="code">RootCliCommand, RootCommand, SubCliCommand, SubCommand, CliCommand, Command, Cli</span>.
            Then the name will be converted to kebab-case, for example:
            <ul><li>If class name is <span class="code">Build</span> or <span class="code">BuildCommand</span> or <span class="code">BuildRootCliCommand</span> -&gt; command name will be <span class="code">build</span></li><li>If class name is <span class="code">BuildText</span> or <span class="code">BuildTextCommand</span> or <span class="code">BuildTextSubCliCommand</span> -&gt; command name will be <span class="code">build-text</span></li></ul></p><p>Default convention can be changed via command's <a href="P_DotMake_CommandLine_CliCommandAttribute_NameCasingConvention.htm">NameCasingConvention</a> property.</p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliCommandAttribute_NameAutoGenerate.htm">NameAutoGenerate</a></td><td>
            Gets or sets a value which indicates whether names are automatically generated for commands, directives, options and arguments.
            <p>Names are converted according to <a href="P_DotMake_CommandLine_CliCommandAttribute_NameCasingConvention.htm">NameCasingConvention</a>.</p><p>
            For options, names typically have a leading delimiter (e.g. <span class="code">--option</span>, <span class="code">-option</span> or <span class="code">/option</span>).
            Default delimiter (e.g. <span class="code">--option</span>) is changed via <a href="P_DotMake_CommandLine_CliCommandAttribute_NamePrefixConvention.htm">NamePrefixConvention</a>.
            </p><p>
            This setting will be inherited by subcommands.
            This setting can be overriden by a subcommand in the inheritance chain.
            </p><p>Default is <a href="T_DotMake_CommandLine_CliNameAutoGenerate.htm">All</a>.</p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliCommandAttribute_NameCasingConvention.htm">NameCasingConvention</a></td><td>
            Gets or sets the character casing convention to use for automatically generated names of commands, directives, options and arguments.
            <p>
            This setting will be inherited by subcommands.
            This setting can be overriden by a subcommand in the inheritance chain.
            </p><p>Default is <a href="T_DotMake_CommandLine_CliNameCasingConvention.htm">KebabCase</a> (e.g. <span class="code">kebab-case</span>).</p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliCommandAttribute_NamePrefixConvention.htm">NamePrefixConvention</a></td><td>
            Gets or sets the prefix convention to use for automatically generated names of options.
            <p>
            For options, names typically have a leading delimiter (e.g. <span class="code">--option</span>, <span class="code">-option</span> or <span class="code">/option</span>).
            </p><p>
            This setting will be inherited by subcommands.
            This setting can be overriden by a subcommand in the inheritance chain.
            </p><p>Default is <a href="T_DotMake_CommandLine_CliNamePrefixConvention.htm">DoubleHyphen</a> (e.g. <span class="code">--option</span>).</p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliCommandAttribute_Parent.htm">Parent</a></td><td>
            Gets or sets the parent of the command. This property is used when you prefer to use a non-nested class for a subcommand,
            i.e. when you want to separate root command and subcommands into different classes/files.
            If the class that this attribute is applied to, is already a nested class, then this property will be ignored.
            </td></tr><tr><td><a href="P_DotMake_CommandLine_CliCommandAttribute_ShortFormAutoGenerate.htm">ShortFormAutoGenerate</a></td><td>
            Gets or sets a value which indicates whether short form aliases are automatically generated names of commands and options.
            <p>
            First letters of every word in the name will be used to create short form to reduce conflicts.
            These first letters are converted according to <a href="P_DotMake_CommandLine_CliCommandAttribute_NameCasingConvention.htm">NameCasingConvention</a>.
            </p><p>
            For options, short forms typically have a leading delimiter (e.g. <span class="code">-o</span> or <span class="code">--o</span> or <span class="code">/o</span>).
            Default delimiter (e.g. <span class="code">-o</span>) is changed via <a href="P_DotMake_CommandLine_CliCommandAttribute_ShortFormPrefixConvention.htm">ShortFormPrefixConvention</a>.
            </p><p>
            This setting will be inherited by subcommands.
            This setting can be overriden by a subcommand in the inheritance chain.
            </p><p>Default is <a href="T_DotMake_CommandLine_CliNameAutoGenerate.htm">All</a>.</p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliCommandAttribute_ShortFormPrefixConvention.htm">ShortFormPrefixConvention</a></td><td>
            Gets or sets the prefix convention to use for automatically generated short form aliases of options.
            <p>
            For options, short forms typically have a leading delimiter (e.g. <span class="code">-o</span> or <span class="code">--o</span> or <span class="code">/o</span>).
            </p><p>
            This setting will be inherited by subcommands.
            This setting can be overriden by a subcommand in the inheritance chain.
            </p><p>Default is <a href="T_DotMake_CommandLine_CliNamePrefixConvention.htm">SingleHyphen</a> (e.g. <span class="code">-o</span>).</p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliCommandAttribute_TreatUnmatchedTokensAsErrors.htm">TreatUnmatchedTokensAsErrors</a></td><td>
            Gets or sets a value that indicates whether unmatched tokens should be treated as errors. For example,
            if set to <span class="keyword"><span id="LSTA4FAE012_3" data-languageSpecificText="vb=True|nu=true"></span></span> and an extra command or argument is provided, validation will fail.
            <p>Default is <span class="keyword"><span id="LSTA4FAE012_4" data-languageSpecificText="vb=True|nu=true"></span></span>.</p></td></tr></table></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>See Also</h2><div id="seeAlsoSection"><h4>Reference</h4><div><a href="N_DotMake_CommandLine.htm">DotMake.CommandLine Namespace</a></div></div></div><div id="InThisArticleColumn" class="column is-hidden-mobile"><nav class="menu sticky is-hidden"><p class="menu-label"><strong>In This Article</strong></p><ul id="InThisArticleMenu" class="menu-list"><li><a class="quickLink">Definition</a></li><li><a class="quickLink">Example</a></li><li><a class="quickLink">Constructors</a></li><li><a class="quickLink">Properties</a></li><li><a class="quickLink">See Also</a></li></ul></nav></div></div></div><footer id="PageFooter" class="footer border-top py-3 fixedFooter"><div class="columns"><div id="FooterContent" class="column"><p>Copyright © 2023-2025 DotMake</p> 
				</div></div></footer></div><script>$(function(){
SetDefaultLanguage("cs");
LoadTocFile(null, null);
InitializeQuickLinks();

$(".toggleSection" ).click(function () {
    SectionExpandCollapse(this);
});

$(".toggleSection").keypress(function () {
    SectionExpandCollapseCheckKey(this, event)
});
hljs.highlightAll();
});</script></body></html>