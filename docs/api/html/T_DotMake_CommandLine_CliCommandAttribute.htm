<!DOCTYPE html ><html lang="en-US"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="shortcut icon" href="../icons/favicon.ico" /><link rel="stylesheet" href="../css/bulma.css" /><link rel="stylesheet" href="../css/font-awesome.min.css" /><link rel="stylesheet" href="../css/presentationStyle.css" /><link rel="stylesheet" href="../css/vs.min.css" /><script src="../scripts/jquery-3.5.1.min.js"></script><script src="../scripts/clipboard.min.js"></script><script src="../scripts/highlight.min.js"></script><script src="../scripts/presentationStyle.js"></script><title>CliCommandAttribute Class</title><meta name="Title" content="CliCommandAttribute" /><meta name="Help.Id" content="T:DotMake.CommandLine.CliCommandAttribute" /><meta name="Help.ContentType" content="Reference" /><meta name="container" content="DotMake.CommandLine" /><meta name="guid" content="T_DotMake_CommandLine_CliCommandAttribute" /><meta name="Description" content="Specifies a class that represents a command which is a specific action that the command line application performs." /><meta name="tocFile" content="../toc/IDAA.xml" /></head><body><div class="fixedLayout"><div id="Header" class="fixedHeader"><div class="pageHeader level mb-0 py-2 px-4"><div id="TitleContainer" class="level-left"><div class="level-item"><img style="height: 64px;" src="../icons/logo128.png" /></div><div id="DocumentationTitle" class="level-item">DotMake Command-Line Documentation</div></div><div id="LangFilterSearchContainer" class="level-right"><div class="level-item"><div class="dropdown is-hoverable"><div class="dropdown-trigger"><button class="button" aria-haspopup="true" aria-controls="dropdown-menu"><span id="CurrentLanguage"></span><span class="icon is-small"><i class="fa fa-angle-down" aria-hidden="true"></i></span></button></div><div class="dropdown-menu" role="menu"><div id="LanguageSelections" class="dropdown-content"><a class="dropdown-item languageFilterItem" data-languageId="cs">C#</a></div></div></div></div><div class="level-item"><form id="SearchForm" action="#" onsubmit="TransferToSearchPage(); return false;"><div class="field"><div class="control has-icons-left"><input id="SearchTerms" class="input" type="text" maxlength="200" placeholder="Search" /><span class="icon is-small is-left"><i class="fa fa-search"></i></span><button id="SearchButton" type="submit" class="is-hidden"></button></div></div></form></div></div></div></div><div class="fixedContent"><nav class="breadcrumb my-1 px-2 border-bottom" role="navigation"><ul id="TopicBreadcrumbs" /></nav><div id="ContentContainer" class="columns pl-5 pr-5 fixedContent"><div id="ShowHideTOCColumn" class="column is-hidden-tablet"><a id="ShowHideTOC">Show/Hide TOC</a></div><div id="TOCColumn" class="column is-hidden-mobile"><nav class="toc"><ul id="TableOfContents" class="toc-menu" /></nav></div><div id="Resizer" class="is-hidden"></div><div id="TopicContent" class="column content is-7"><h1>Cli<wbr />Command<wbr />Attribute Class</h1><div class="summary">
            Specifies a class that represents a command which is a specific action that the command line application performs.
            <div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">[CliCommand]
public class SomeCliCommand</code></pre></div></div>
            The class that this attribute is applied to, 
            <ul><li>will be a root command if the class is not a nested class and <a href="P_DotMake_CommandLine_CliCommandAttribute_Parent.htm">Parent</a> property is not set.</li><li>will be a sub command if the class is a nested class or <a href="P_DotMake_CommandLine_CliCommandAttribute_Parent.htm">Parent</a> property is set.</li></ul><p><b>Commands:</b> A command in command-line input is a token that specifies an action or defines a group of related actions. For example:
            <ul><li>In <span class="code">dotnet run</span>, <span class="code">run</span> is a command that specifies an action.</li><li>In <span class="code">dotnet tool install</span>, <span class="code">install</span> is a command that specifies an action, and <span class="code">tool</span> is a command that specifies a <br />
                    group of related commands. There are other tool-related commands, such as <span class="code">tool uninstall</span>, <span class="code">tool list</span>,<br />
                    and <span class="code">tool update</span>.</li></ul></p><p><b>Root commands:</b> The root command is the one that specifies the name of the app's executable. For example, the <span class="code">dotnet</span> command specifies the <span class="code">dotnet.exe</span> executable.
            </p><p><b>Subcommands:</b> Most command-line apps support subcommands, also known as verbs. For example, the <span class="code">dotnet</span> command has a <span class="code">run</span> subcommand that you invoke by entering <span class="code">dotnet run</span>.
            Subcommands can have their own subcommands. In <span class="code">dotnet tool install</span>, <span class="code">install</span> is a <span class="code">subcommand</span> of tool.
            </p><p>
            When you have repeating/common options and arguments for your commands, you can define them once in a base class and then 
            share them by inheriting that base class in other command classes.Interfaces are also supported !
            </p></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Definition</h2><div id="IDBSection"><strong>Namespace:</strong> <a href="N_DotMake_CommandLine.htm">DotMake.CommandLine</a><br /><strong>Assembly:</strong> DotMake.CommandLine (in DotMake.CommandLine.dll) Version: 1.8.2<div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><span class="buttons"><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></span></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs"><span class="keyword">public</span> <span class="keyword">class</span> <span class="identifier">CliCommandAttribute</span> : <span class="identifier">Attribute</span></code></pre></div></div><dl class="inheritanceHierarchy"><dt>Inheritance</dt><dd><a href="https://docs.microsoft.com/dotnet/api/system.object" target="_blank" rel="noopener noreferrer">Object</a>  <span class="icon is-small"><i class="fa fa-arrow-right"></i></span>  <a href="https://docs.microsoft.com/dotnet/api/system.attribute" target="_blank" rel="noopener noreferrer">Attribute</a>  <span class="icon is-small"><i class="fa fa-arrow-right"></i></span>  <span class="selflink">CliCommandAttribute</span></dd></dl></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Example</h2><div id="IDBCSection"><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// Class-based model
// Create a simple class like this:

[CliCommand(Description = "A root cli command")]
public class RootCliCommand
{
    [CliOption(Description = "Description for Option1")]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = "Description for Argument1")]
    public string Argument1 { get; set; }

    public void Run()
    {
        Console.WriteLine($@"Handler for '{GetType().FullName}' is run:");
        Console.WriteLine($@"Value for {nameof(Option1)} property is '{Option1}'");
        Console.WriteLine($@"Value for {nameof(Argument1)} property is '{Argument1}'");
        Console.WriteLine();
    }
}

        //In Program.cs, add this single line:
        Cli.Run&lt;RootCliCommand&gt;(args);

        //If you need to simply parse the command-line arguments without invocation, use this:
        var parseResult = Cli.Parse&lt;RootCliCommand&gt;(args);
        var rootCliCommand = parseResult.Bind&lt;RootCliCommand&gt;();</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// Note that you can have a specific type (other than `string`) for a property which a `CliOption` or `CliArgument`
// attribute is applied to, for example these properties will be parsed and bound/populated automatically:

[CliCommand]
public class WriteFileCommand
{
    [CliArgument]
    public FileInfo OutputFile { get; set; }

    [CliOption]
    public List&lt;string&gt; Lines { get; set; }

    public void Run()
    {
        if (OutputFile.Exists)
            return;

        using (var streamWriter = OutputFile.CreateText())
        {
            foreach (var line in Lines)
            {
                streamWriter.WriteLine(line);
            }
        }
    }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// Any type with a public constructor or a static `Parse` method with a string parameter (other parameters, if any,
// should be optional) - These types can be bound/parsed automatically even if they are wrapped
// with `Enumerable` or `Nullable` type.

[CliCommand]
public class ArgumentConverterCliCommand
{
    [CliOption(Required = false)]
    public ClassWithConstructor Opt { get; set; }

    [CliOption(Required = false, AllowMultipleArgumentsPerToken = true)]
    public ClassWithConstructor[] OptArray { get; set; }

    [CliOption(Required = false)]
    public CustomStruct? OptNullable { get; set; }

    [CliOption(Required = false)]
    public IEnumerable&lt;ClassWithConstructor&gt; OptEnumerable { get; set; }

    [CliOption(Required = false)]
    public List&lt;ClassWithConstructor&gt; OptList { get; set; }

    [CliOption(Required = false)]
    public CustomList&lt;ClassWithConstructor&gt; OptCustomList { get; set; }

    [CliArgument]
    public IEnumerable&lt;ClassWithParser&gt; Arg { get; set; }

    public void Run(CliContext context)
    {
        context.ShowValues();
    }
}

public class ClassWithConstructor
{
    private readonly string value;

    public ClassWithConstructor(string value)
    {
        if (value == "exception")
            throw new Exception("Exception in ClassWithConstructor");

        this.value = value;
    }

    public override string ToString()
    {
        return value;
    }
}

public class ClassWithParser
{
    private string value;

    public override string ToString()
    {
        return value;
    }

    public static ClassWithParser Parse(string value)
    {
        if (value == "exception")
            throw new Exception("Exception in ClassWithParser");

        var instance = new ClassWithParser();
        instance.value = value;
        return instance;
    }
}

public struct CustomStruct
{
    private readonly string value;

    public CustomStruct(string value)
    {
        this.value = value;
    }

    public override string ToString()
    {
        return value;
    }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// Arrays, lists, collections - any type that implements `IEnumerable&lt;T&gt;` and has a public constructor with a `IEnumerable&lt;T&gt;`
// or `IList&lt;T&gt;` parameter (other parameters, if any, should be optional).
// If type is generic `IEnumerable&lt;T&gt;`, `IList&lt;T&gt;`, `ICollection&lt;T&gt;` interfaces itself, array `T[]` will be used.
// If type is non-generic `IEnumerable`, `IList`, `ICollection` interfaces itself, array `string[]` will be used.

[CliCommand]
public class EnumerableCliCommand
{
    [CliOption(Required = false)]
    public IEnumerable&lt;int&gt; OptEnumerable { get; set; }

    [CliOption(Required = false)]
    public List&lt;string&gt; OptList { get; set; }

    [CliOption(Required = false, AllowMultipleArgumentsPerToken = true)]
    public FileAccess[] OptEnumArray { get; set; }

    [CliOption(Required = false)]
    public Collection&lt;int?&gt; OptCollection { get; set; }

    [CliOption(Required = false)]
    public HashSet&lt;string&gt; OptHashSet { get; set; }

    [CliOption(Required = false)]
    public Queue&lt;FileInfo&gt; OptQueue { get; set; }

    [CliOption(Required = false)]
    public CustomList&lt;string&gt; OptCustomList { get; set; }

    [CliArgument]
    public IList ArgIList { get; set; }

    public void Run(CliContext context)
    {
        context.ShowValues();
    }
}

public class CustomList&lt;T&gt; : List&lt;T&gt;
{
    public CustomList(IEnumerable&lt;T&gt; items)
        : base(items)
    {
        if (items is IEnumerable&lt;string&gt; strings &amp;&amp; strings.First() == "exception")
            throw new Exception("Exception in CustomList");
    }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// For example, change the name casing and prefix convention:

[CliCommand(
    Description = "A cli command with snake_case name casing and forward slash prefix conventions",
    NameCasingConvention = CliNameCasingConvention.SnakeCase,
    NamePrefixConvention = CliNamePrefixConvention.ForwardSlash,
    ShortFormPrefixConvention = CliNamePrefixConvention.ForwardSlash
)]
public class RootSnakeSlashCliCommand
{
    [CliOption(Description = "Description for Option1")]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = "Description for Argument1")]
    public string Argument1 { get; set; }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// Defining sub-commands in DotMake.Commandline is very easy. We simply use nested classes to create a hierarchy.
// Just make sure you apply `CliCommand` attribute to the nested classes as well.
// Command hierarchy in below example is:  
// `RootWithNestedChildrenCliCommand` -&gt; `Level1SubCliCommand` -&gt; `Level2SubCliCommand`

[CliCommand(Description = "A root cli command with nested children")]
public class RootWithNestedChildrenCliCommand
{
    [CliOption(Description = "Description for Option1")]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = "Description for Argument1")]
    public string Argument1 { get; set; }

    public void Run(CliContext context)
    {
        context.ShowValues();
    }

    [CliCommand(Description = "A nested level 1 sub-command")]
    public class Level1SubCliCommand
    {
        [CliOption(Description = "Description for Option1")]
        public string Option1 { get; set; } = "DefaultForOption1";

        [CliArgument(Description = "Description for Argument1")]
        public string Argument1 { get; set; }

        public void Run(CliContext context)
        {
            context.ShowValues();
        }

        [CliCommand(Description = "A nested level 2 sub-command")]
        public class Level2SubCliCommand
        {
            [CliOption(Description = "Description for Option1")]
            public string Option1 { get; set; } = "DefaultForOption1";

            [CliArgument(Description = "Description for Argument1")]
            public string Argument1 { get; set; }

            public void Run(CliContext context)
            {
                context.ShowValues();
            }
        }
    }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// Another way to create hierarchy between commands, especially if you want to use standalone classes,
// is to use `Parent` property of `CliCommand` attribute to specify `typeof` parent class.
// Consider you have this root command:

[CliCommand(Description = "A root cli command with external children and one nested child and testing settings inheritance")]
public class RootWithExternalChildrenCliCommand
{
    [CliOption(Description = "Description for Option1")]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = "Description for Argument1")]
    public string Argument1 { get; set; }

    public void Run(CliContext context)
    {
        context.ShowValues();
    }

    [CliCommand(
        Description = "A nested level 1 sub-command with custom settings, throws test exception",
        NameCasingConvention = CliNameCasingConvention.SnakeCase,
        NamePrefixConvention = CliNamePrefixConvention.ForwardSlash,
        ShortFormPrefixConvention = CliNamePrefixConvention.ForwardSlash
    )]
    public class Level1SubCliCommand
    {
        [CliOption(Description = "Description for Option1")]
        public string Option1 { get; set; } = "DefaultForOption1";

        [CliArgument(Description = "Description for Argument1")]
        public string Argument1 { get; set; }

        public void Run()
        {
            throw new Exception("This is a test exception from Level1SubCliCommand");
        }
    }
}

// Command hierarchy in below example is:  
// `RootWithExternalChildrenCliCommand` -&gt; `ExternalLevel1SubCliCommand` -&gt; `Level2SubCliCommand`

[CliCommand(
    Description = "An external level 1 sub-command",
    Parent = typeof(RootWithExternalChildrenCliCommand)
)]
public class ExternalLevel1SubCliCommand
{
    [CliOption(Description = "Description for Option1")]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = "Description for Argument1")]
    public string Argument1 { get; set; }

    public void Run(CliContext context)
    {
        context.ShowValues();
    }

    [CliCommand(Description = "A nested level 2 sub-command")]
    public class Level2SubCliCommand
    {
        [CliOption(Description = "Description for Option1")]
        public string Option1 { get; set; } = "DefaultForOption1";

        [CliArgument(Description = "Description for Argument1")]
        public string Argument1 { get; set; }

        public void Run(CliContext context)
        {
            context.ShowValues();
        }
    }
}

// Command hierarchy in below example is:  
// `RootWithExternalChildrenCliCommand` -&gt; `Level1SubCliCommand` -&gt; `ExternalLevel2SubCliCommand` -&gt; `Level3SubCliCommand`

[CliCommand(
    Description = "An external level 2 sub-command",
    Parent = typeof(RootWithExternalChildrenCliCommand.Level1SubCliCommand),
    NameCasingConvention = CliNameCasingConvention.SnakeCase,
    NamePrefixConvention = CliNamePrefixConvention.ForwardSlash,
    ShortFormPrefixConvention = CliNamePrefixConvention.ForwardSlash
)]
public class ExternalLevel2SubCliCommand
{
    [CliOption(Description = "Description for Option1")]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = "Description for Argument1")]
    public string Argument1 { get; set; }

    public void Run(CliContext context)
    {
        context.ShowValues();
    }

    [CliCommand(Description = "A nested level 3 sub-command")]
    public class Level3SubCliCommand
    {
        [CliOption(Description = "Description for Option1")]
        public string Option1 { get; set; } = "DefaultForOption1";

        [CliArgument(Description = "Description for Argument1")]
        public string Argument1 { get; set; }

        public void Run(CliContext context)
        {
            context.ShowValues();
        }
    }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// When you have repeating/common options and arguments for your commands, you can define them once in a base class and then 
// share them by inheriting that base class in other command classes.Interfaces are also supported !

// The property attribute and the property initializer from the most derived class in the hierarchy will be used 
// (they will override the base ones). The command handler (Run or RunAsync) will be also inherited.
// So in the above example, `InheritanceCliCommand` inherits options `Username`, `Password` from a base class and
// option `Department` from an interface. Note that the property initializer for `Department` is in the derived class, 
// so that default value will be used.

[CliCommand]
public class InheritanceCliCommand : CredentialCommandBase, IDepartmentCommand
{
    public string Department { get; set; } = "Accounting";
}

public abstract class CredentialCommandBase
{
    [CliOption(Description = "Username of the identity performing the command")]
    public string Username { get; set; } = "admin";

    [CliOption(Description = "Password of the identity performing the command")]
    public string Password { get; set; }

    public void Run()
    {
        Console.WriteLine($@"I am {Username}");
    }
}

public interface IDepartmentCommand
{
    [CliOption(Description = "Department of the identity performing the command (interface)")]
    string Department { get; set; }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// Localizing commands, options and arguments is supported.
// You can specify a `nameof` operator expression with a resource property (generated by resx) in the attribute's argument (for `string` types only)
// and the source generator will smartly use the resource property accessor as the value of the argument so that it can localize at runtime.
// If the property in the `nameof` operator expression does not point to a resource property, then the name of that property will be used as usual.
// The reason we use `nameof` operator is that attributes in `.NET` only accept compile-time constants and you get `CS0182` error if not,
// so specifying resource property directly is not possible as it's not a compile-time constant but it's a static property access.

[CliCommand(Description = nameof(TestResources.CommandDescription))]
internal class LocalizedCliCommand
{
    [CliOption(Description = nameof(TestResources.OptionDescription))]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = nameof(TestResources.ArgumentDescription))]
    public string Argument1 { get; set; }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// If a command represents a group and not an action, you may want to show help.
// If `Run` or `RunAsync` method is missing in a command class, then by default it will show help.
// You can also manually trigger help in `Run` or `RunAsync` method of a command class via calling `CliContext.ShowHelp`.
// For testing a command, other methods `CliContext.ShowValues` and `CliContext.IsEmptyCommand` are also useful.
// `ShowValues` shows parsed values for current command and its arguments and options.

// See below example; root command does not have a handler method so it will always show help
// and sub-command will show help if command is specified without any arguments or option,
// and it will show(dump) values if not:

[CliCommand(Description = "A root cli command")]
public class HelpCliCommand
{
    [CliOption(Description = "Description for Option1")]
    public string Option1 { get; set; } = "DefaultForOption1";

    [CliArgument(Description = "Description for Argument1")]
    public string Argument1 { get; set; } = "DefaultForArgument1";

    [CliCommand(Description = "A sub cli command")]
    public class SubCliCommand
    {
        [CliArgument(Description = "Description for Argument2")]
        public string Argument2 { get; set; } = "DefaultForArgument2";

        public void Run(CliContext context)
        {
            if (context.IsEmptyCommand())
                context.ShowHelp();
            else
                context.ShowValues();
        }
    }
}</code></pre></div></div><div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">// In `[CliOption]` and `[CliArgument]` attributes;
// `ValidationRules` property allows setting predefined validation rules such as `ExistingFile`, `NonExistingFile`, `ExistingDirectory`,
// `NonExistingDirectory`, `ExistingFileOrDirectory`, `NonExistingFileOrDirectory`, `LegalPath`, `LegalFileName`, `LegalUri`, `LegalUrl`.
// Validation rules can be combined.
// `ValidationPattern` property allows setting a regular expression pattern for custom validation,
// and `ValidationMessage` property allows setting a custom error message to show when `ValidationPattern` does not match.

[CliCommand]
public class ValidationCliCommand
{
    [CliOption(Required = false, ValidationRules = CliValidationRules.ExistingFile)]
    public FileInfo OptFile1 { get; set; }

    [CliOption(Required = false, ValidationRules = CliValidationRules.NonExistingFile | CliValidationRules.LegalPath)]
    public string OptFile2 { get; set; }

    [CliOption(Required = false, ValidationRules = CliValidationRules.ExistingDirectory)]
    public DirectoryInfo OptDir { get; set; }

    [CliOption(Required = false, ValidationPattern = @"(?i)^[a-z]+$")]
    public string OptPattern1 { get; set; }

    [CliOption(Required = false, ValidationPattern = @"(?i)^[a-z]+$", ValidationMessage = "Custom error message")]
    public string OptPattern2 { get; set; }

    [CliOption(Required = false, ValidationRules = CliValidationRules.LegalUrl)]
    public string OptUrl { get; set; }

    [CliOption(Required = false, ValidationRules = CliValidationRules.LegalUri)]
    public string OptUri { get; set; }

    [CliArgument(Required = false, ValidationRules = CliValidationRules.LegalFileName)]
    public string OptFileName { get; set; }

    public void Run(CliContext context)
    {
        context.ShowValues();
    }
}</code></pre></div></div></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Constructors</h2><div id="IDAEASection"><table id="ConstructorList" class="table is-hoverable"><tr><td><a href="M_DotMake_CommandLine_CliCommandAttribute__ctor.htm">CliCommandAttribute</a></td><td>Initializes a new instance of the <span class="selflink">CliCommandAttribute</span> class</td></tr></table></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Properties</h2><div id="IDBEASection"><table id="PropertyList" class="table is-hoverable"><tr><td><a href="P_DotMake_CommandLine_CliCommandAttribute_Aliases.htm">Aliases</a></td><td>
            Gets or sets the set of alternative strings that can be used on the command line to specify the command.
            <p>The aliases will be also displayed in usage help of the command line application.</p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliCommandAttribute_Description.htm">Description</a></td><td>
            Gets or sets the description of the command. This will be displayed in usage help of the command line application.
            </td></tr><tr><td><a href="P_DotMake_CommandLine_CliCommandAttribute_Hidden.htm">Hidden</a></td><td>
            Gets or sets a value indicating whether the command is hidden.
            <p>
            You might want to support a command, option, or argument, but avoid making it easy to discover.
            For example, it might be a deprecated or administrative or preview feature.
            Use the <a href="P_DotMake_CommandLine_CliCommandAttribute_Hidden.htm">Hidden</a> property to prevent users from discovering such features by using tab completion or help.
            </p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliCommandAttribute_Name.htm">Name</a></td><td>
            Gets or sets the name of the command that will be used on the command line to specify the command.
            This will be displayed in usage help of the command line application.
            <p>
            If not set (or is empty/whitespace), the name of the class that this attribute is applied to, will be used to generate command name automatically:
            These suffixes will be stripped from the class name: <span class="code">RootCliCommand, RootCommand, SubCliCommand, SubCommand, CliCommand, Command, Cli</span>.
            Then the name will be converted to kebab-case, for example:
            <ul><li>If class name is <span class="code">Build</span> or <span class="code">BuildCommand</span> or <span class="code">BuildRootCliCommand</span> -&gt; command name will be <span class="code">build</span></li><li>If class name is <span class="code">BuildText</span> or <span class="code">BuildTextCommand</span> or <span class="code">BuildTextSubCliCommand</span> -&gt; command name will be <span class="code">build-text</span></li></ul></p><p>Default convention can be changed via command's <a href="P_DotMake_CommandLine_CliCommandAttribute_NameCasingConvention.htm">NameCasingConvention</a> property.</p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliCommandAttribute_NameCasingConvention.htm">NameCasingConvention</a></td><td>
            Gets or sets the character casing convention to use for automatically generated command, option and argument names.
            This setting will be inherited by child options, child arguments and subcommands.
            This setting can be overriden by a subcommand in the inheritance chain.
            <p>Default is <a href="T_DotMake_CommandLine_CliNameCasingConvention.htm">KebabCase</a> (e.g. <span class="code">kebab-case</span>).</p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliCommandAttribute_NamePrefixConvention.htm">NamePrefixConvention</a></td><td>
            Gets or sets the prefix convention to use for automatically generated option names.
            This setting will be inherited by child options and subcommands.
            This setting can be overriden by a subcommand in the inheritance chain.
            <p>Default is <a href="T_DotMake_CommandLine_CliNamePrefixConvention.htm">DoubleHyphen</a> (e.g. <span class="code">--option</span>).</p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliCommandAttribute_Parent.htm">Parent</a></td><td>
            Gets or sets the parent of the command. This property is used when you prefer to use a non-nested class for a subcommand,
            i.e. when you want to separate root command and subcommands into different classes/files.
            If the class that this attribute is applied to, is already a nested class, then this property will be ignored.
            </td></tr><tr><td><a href="P_DotMake_CommandLine_CliCommandAttribute_ShortFormAutoGenerate.htm">ShortFormAutoGenerate</a></td><td>
            Gets or sets a value which indicates whether short form aliases are automatically generated for options.
            Short forms typically have a leading delimiter followed by a single character (e.g. <span class="code">-o</span> or <span class="code">--o</span> or <span class="code">/o</span>).
            Default delimiter (e.g. <span class="code">-o</span>) is changed via <a href="P_DotMake_CommandLine_CliCommandAttribute_ShortFormPrefixConvention.htm">ShortFormPrefixConvention</a>.
            This setting will be inherited by child options and subcommands.
            This setting can be overriden by a subcommand in the inheritance chain.
            <p>Default is <span class="keyword"><span id="LSTA4FAE012_0" data-languageSpecificText="vb=True|nu=true"></span></span>.</p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliCommandAttribute_ShortFormPrefixConvention.htm">ShortFormPrefixConvention</a></td><td>
            Gets or sets the prefix convention to use for automatically generated short form option aliases.
            Short forms typically have a leading delimiter followed by a single character (e.g. <span class="code">-o</span> or <span class="code">--o</span> or <span class="code">/o</span>).
            This setting will be inherited by child options and subcommands.
            This setting can be overriden by a subcommand in the inheritance chain.
            <p>Default is <a href="T_DotMake_CommandLine_CliNamePrefixConvention.htm">SingleHyphen</a> (e.g. <span class="code">-o</span>).</p></td></tr><tr><td><a href="P_DotMake_CommandLine_CliCommandAttribute_TreatUnmatchedTokensAsErrors.htm">TreatUnmatchedTokensAsErrors</a></td><td>
            Gets or sets a value that indicates whether unmatched tokens should be treated as errors. For example,
            if set to <span class="keyword"><span id="LSTA4FAE012_1" data-languageSpecificText="vb=True|nu=true"></span></span> and an extra command or argument is provided, validation will fail.
            <p>Default is <span class="keyword"><span id="LSTA4FAE012_2" data-languageSpecificText="vb=True|nu=true"></span></span>.</p></td></tr></table></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>See Also</h2><div id="seeAlsoSection"><h4>Reference</h4><div><a href="N_DotMake_CommandLine.htm">DotMake.CommandLine Namespace</a></div></div></div><div id="InThisArticleColumn" class="column is-hidden-mobile"><nav class="menu sticky is-hidden"><p class="menu-label"><strong>In This Article</strong></p><ul id="InThisArticleMenu" class="menu-list"><li><a class="quickLink">Definition</a></li><li><a class="quickLink">Example</a></li><li><a class="quickLink">Constructors</a></li><li><a class="quickLink">Properties</a></li><li><a class="quickLink">See Also</a></li></ul></nav></div></div></div><footer id="PageFooter" class="footer border-top py-3 fixedFooter"><div class="columns"><div class="column"><p>Copyright © 2023-2024 DotMake</p> 
				</div><div class="column"> 
				</div></div></footer></div><script>$(function(){
SetDefaultLanguage("cs");
LoadTocFile(null, null);
InitializeQuickLinks();

$(".toggleSection" ).click(function () {
    SectionExpandCollapse(this);
});

$(".toggleSection").keypress(function () {
    SectionExpandCollapseCheckKey(this, event)
});
hljs.highlightAll();
});</script></body></html>